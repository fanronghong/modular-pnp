# Copyright (C) 2014 CCMA@PSU Maximilian Metti, Xiaozhe Hu
#
#   Define bilinear and linear forms for 
#   the linearized Poisson-Nernst-Planck equations for a MOSFET
#
# Compile this form with FFC: ffc -O -l dolfin mosfet.ufl.

##  Finite Element Space
CG = FiniteElement("Lagrange", tetrahedron, 1)
Vit  = FiniteElement("RT", tetrahedron, 1)
Pres  = FiniteElement("Discontinuous Lagrange", tetrahedron, 0)
V  = MixedElement([CG,CG,CG,Vit,Pres])        # Solution Space
#V  = MixedElement([CG,CG,CG])*Vit*Pres       # Solution Space
#V = CG * CG * CG * Vit * Pres

(Cat, An, Phi, u, p) = TrialFunctions(V)
(cat, an, phi, v, q) = TestFunctions(V)


##  Previous Iterates
CatCat = Coefficient(CG)
AnAn = Coefficient(CG)
EsEs = Coefficient(CG)
uu  = Coefficient(Vit)
pp  = Coefficient(Pres)


##  Coefficients
eps = Coefficient(CG)
Dp = Coefficient(CG)
qp = Constant(tetrahedron)
Dn = Coefficient(CG)
qn = Constant(tetrahedron)

## Analytic solution
cation = Coefficient(CG)
anion = Coefficient(CG)
potential = Coefficient(CG)

##  Coefficients
mu  = Constant(tetrahedron)

##  DG-terms
alpha1 = Constant(tetrahedron)
alpha2 = Constant(tetrahedron)
h     = 2.0*Circumradius(tetrahedron)
h_avg = ( h('+')+h('-') )/2.0
n_vec = FacetNormal(tetrahedron)

a   = ( Dp*( inner(grad(Cat),grad(cat)) + inner(qp*grad(EsEs),grad(cat)) * Cat ) )*dx \
    + ( qp*Dp*CatCat * inner(grad(Phi),grad(cat)) )*dx \
    + ( Dn*( inner(grad(An),grad(an)) + inner(qn*grad(EsEs), grad(an)) * An ) )*dx \
    + ( qn*Dn*AnAn * inner(grad(Phi),grad(an)) )*dx \
    + ( eps * inner(grad(Phi),grad(phi)) )*dx \
    + ( -(qp*Cat + qn*An)*phi )*dx \
    - ( Cat*(inner(uu,grad(cat))) )*dx \
    - ( An*(inner(uu,grad(an)))  )*dx \
    - ( CatCat*(inner(u,grad(cat))) )*dx \
    - ( AnAn*(inner(u,grad(an)))  )*dx \
    + ( 2.0*mu* inner( sym(grad(u)), sym(grad(v)) ) )*dx    -    ( p*div(v) )*dx   +   ( div(u)*q )*dx \
    + ( 2.0*mu*(alpha1)* inner( avg(sym(grad(u))), sym(outer(v('+'),n_vec('+')) + outer(v('-'),n_vec('-'))) ) )*dS \
    + ( 2.0*mu*(alpha1)* inner( sym(outer(u('+'),n_vec('+')) + outer(u('-'),n_vec('-'))), avg(sym(grad(v))) ) )*dS \
    + ( 2.0*mu*(alpha2/h_avg)* inner( jump(u),jump(v) ) )*dS \
    + ( (qp*CatCat+qn*AnAn)*inner( grad(Phi),v ) )*dx \
    + ( (qp*Cat+qn*An)*inner(grad(EsEs),v) )*dx

L   = - ( Dp*(inner(grad(CatCat),grad(cat)) + qp*CatCat*inner(grad(EsEs),grad(cat))) )*dx \
    - ( Dn*(inner(grad(AnAn  ),grad(an )) + qn*AnAn*inner(grad(EsEs), grad(an))) )*dx \
    - ( eps * inner(grad(EsEs),grad(phi)) )*dx \
    - ( -(qp*CatCat + qn*AnAn)*phi )*dx \
    + ( CatCat*(inner(uu,grad(cat))) )*dx \
    + ( AnAn*(inner(uu,grad(an)))  )*dx \
    - ( 2.0*mu* inner( sym(grad(uu)), sym(grad(v)) ) )*dx   +   ( pp*div(v) )*dx   -   ( div(uu)*q )*dx \
    - ( 2.0*mu*(alpha1)* inner( avg(sym(grad(uu))),  sym(outer(v('+'),n_vec('+')) + outer(v('-'),n_vec('-'))) ) )*dS \
    - ( 2.0*mu*(alpha1)* inner( sym(outer(uu('+'),n_vec('+')) + outer(uu('-'),n_vec('-'))), avg(sym(grad(v))) ) )*dS \
    - ( 2.0*mu*(alpha2/h_avg)* inner( jump(uu),jump(v) ) )*dS \
    - ( (qp*CatCat+qn*AnAn)*inner( grad(EsEs),v ) )*dx \
