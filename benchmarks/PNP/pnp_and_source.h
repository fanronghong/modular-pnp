// This code conforms with the UFC specification version 2016.1.0
// and was automatically generated by FFC version 2016.1.0.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
// 
// This code was generated with the following parameters:
// 
//   convert_exceptions_to_warnings: False
//   cpp_optimize:                   True
//   cpp_optimize_flags:             '-O2'
//   epsilon:                        1e-14
//   error_control:                  False
//   form_postfix:                   True
//   format:                         'dolfin'
//   optimize:                       True
//   precision:                      15
//   quadrature_degree:              -1
//   quadrature_rule:                'auto'
//   representation:                 'auto'
//   split:                          False

#ifndef __PNP_AND_SOURCE_H
#define __PNP_AND_SOURCE_H
#include <cmath>
#include <stdexcept>
#include <ufc.h>

class pnp_and_source_finite_element_0: public ufc::finite_element
{
public:

  pnp_and_source_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  ~pnp_and_source_finite_element_0() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FiniteElement('Lagrange', tetrahedron, 1)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::tetrahedron;
  }

  std::size_t topological_dimension() const final override
  {
    return 3;
  }

  std::size_t geometric_dimension() const final override
  {
    return 3;
  }

  std::size_t space_dimension() const final override
  {
    return 4;
  }

  std::size_t value_rank() const final override
  {
    return 0;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t value_size() const final override
  {
    return 1;
  }

  std::size_t reference_value_rank() const final override
  {
    return 0;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t reference_value_size() const final override
  {
    return 1;
  }

  std::size_t degree() const final override
  {
    return 1;
  }

  const char * family() const final override
  {
    return "Lagrange";
  }

  static void _evaluate_basis(std::size_t i,
                              double * values,
                              const double * x,
                              const double * coordinate_dofs,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = coordinate_dofs[9]  + coordinate_dofs[6] + coordinate_dofs[3]  - coordinate_dofs[0];
    const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4]  - coordinate_dofs[1];
    const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5]  - coordinate_dofs[2];
    
    // Compute subdeterminants
    const double d_00 = J[4]*J[8] - J[5]*J[7];
    const double d_01 = J[5]*J[6] - J[3]*J[8];
    const double d_02 = J[3]*J[7] - J[4]*J[6];
    const double d_10 = J[2]*J[7] - J[1]*J[8];
    const double d_11 = J[0]*J[8] - J[2]*J[6];
    const double d_12 = J[1]*J[6] - J[0]*J[7];
    const double d_20 = J[1]*J[5] - J[2]*J[4];
    const double d_21 = J[2]*J[3] - J[0]*J[5];
    const double d_22 = J[0]*J[4] - J[1]*J[3];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (d_00*(2.0*x[0] - C0) + d_10*(2.0*x[1] - C1) + d_20*(2.0*x[2] - C2)) / detJ;
    double Y = (d_01*(2.0*x[0] - C0) + d_11*(2.0*x[1] - C1) + d_21*(2.0*x[2] - C2)) / detJ;
    double Z = (d_02*(2.0*x[0] - C0) + d_12*(2.0*x[1] - C1) + d_22*(2.0*x[2] - C2)) / detJ;
    
    
    // Reset values
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.210818510677892, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.0, 0.223606797749979};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation) const final override
  {
    _evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
  }

  static void _evaluate_basis_all(double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 4; r++)
    {
      _evaluate_basis(r, &dof_values, x, coordinate_dofs, cell_orientation);
      values[r] = dof_values;
    } // end loop over 'r'
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation) const final override
  {
    _evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
  }

  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double * values,
                                          const double * x,
                                          const double * coordinate_dofs,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = coordinate_dofs[9]  + coordinate_dofs[6] + coordinate_dofs[3]  - coordinate_dofs[0];
    const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4]  - coordinate_dofs[1];
    const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5]  - coordinate_dofs[2];
    
    // Compute subdeterminants
    const double d_00 = J[4]*J[8] - J[5]*J[7];
    const double d_01 = J[5]*J[6] - J[3]*J[8];
    const double d_02 = J[3]*J[7] - J[4]*J[6];
    const double d_10 = J[2]*J[7] - J[1]*J[8];
    const double d_11 = J[0]*J[8] - J[2]*J[6];
    const double d_12 = J[1]*J[6] - J[0]*J[7];
    const double d_20 = J[1]*J[5] - J[2]*J[4];
    const double d_21 = J[2]*J[3] - J[0]*J[5];
    const double d_22 = J[0]*J[4] - J[1]*J[3];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (d_00*(2.0*x[0] - C0) + d_10*(2.0*x[1] - C1) + d_20*(2.0*x[2] - C2)) / detJ;
    double Y = (d_01*(2.0*x[0] - C0) + d_11*(2.0*x[1] - C1) + d_21*(2.0*x[2] - C2)) / detJ;
    double Z = (d_02*(2.0*x[0] - C0) + d_12*(2.0*x[1] - C1) + d_22*(2.0*x[2] - C2)) / detJ;
    
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[3][1];
    for (unsigned int row = 0; row < 3; row++)
    {
      for (unsigned int col = 0; col < 1; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 2)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[3][3] = {{K[0], K[1], K[2]}, {K[3], K[4], K[5]}, {K[6], K[7], K[8]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[3][3];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.210818510677892, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.0, 0.223606797749979};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    }
    
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation) const final override
  {
    _evaluate_basis_derivatives(i, n, values, x, coordinate_dofs, cell_orientation);
  }

  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double * values,
                                              const double * x,
                                              const double * coordinate_dofs,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 4; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[3];
    for (unsigned int r = 0; r < 3; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 4; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation) const final override
  {
    _evaluate_basis_derivatives_all(n, values, x, coordinate_dofs, cell_orientation);
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
      {
        y[0] = coordinate_dofs[0];
      y[1] = coordinate_dofs[1];
      y[2] = coordinate_dofs[2];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = coordinate_dofs[3];
      y[1] = coordinate_dofs[4];
      y[2] = coordinate_dofs[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = coordinate_dofs[6];
      y[1] = coordinate_dofs[7];
      y[2] = coordinate_dofs[8];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = coordinate_dofs[9];
      y[1] = coordinate_dofs[10];
      y[2] = coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[3];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::cell& c) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
    vertex_values[3] = dof_values[3];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs) const final override
  {
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[3] = coordinate_dofs[3];
    dof_coordinates[4] = coordinate_dofs[4];
    dof_coordinates[5] = coordinate_dofs[5];
    dof_coordinates[6] = coordinate_dofs[6];
    dof_coordinates[7] = coordinate_dofs[7];
    dof_coordinates[8] = coordinate_dofs[8];
    dof_coordinates[9] = coordinate_dofs[9];
    dof_coordinates[10] = coordinate_dofs[10];
    dof_coordinates[11] = coordinate_dofs[11];
  }

  std::size_t num_sub_elements() const final override
  {
    return 0;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    return 0;
  }

  ufc::finite_element * create() const final override
  {
    return new pnp_and_source_finite_element_0();
  }

};


class pnp_and_source_finite_element_1: public ufc::finite_element
{
public:

  pnp_and_source_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  ~pnp_and_source_finite_element_1() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "VectorElement(FiniteElement('Lagrange', tetrahedron, 1), dim=3)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::tetrahedron;
  }

  std::size_t topological_dimension() const final override
  {
    return 3;
  }

  std::size_t geometric_dimension() const final override
  {
    return 3;
  }

  std::size_t space_dimension() const final override
  {
    return 12;
  }

  std::size_t value_rank() const final override
  {
    return 1;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  std::size_t value_size() const final override
  {
    return 3;
  }

  std::size_t reference_value_rank() const final override
  {
    return 1;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  std::size_t reference_value_size() const final override
  {
    return 3;
  }

  std::size_t degree() const final override
  {
    return 1;
  }

  const char * family() const final override
  {
    return "Lagrange";
  }

  static void _evaluate_basis(std::size_t i,
                              double * values,
                              const double * x,
                              const double * coordinate_dofs,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = coordinate_dofs[9]  + coordinate_dofs[6] + coordinate_dofs[3]  - coordinate_dofs[0];
    const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4]  - coordinate_dofs[1];
    const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5]  - coordinate_dofs[2];
    
    // Compute subdeterminants
    const double d_00 = J[4]*J[8] - J[5]*J[7];
    const double d_01 = J[5]*J[6] - J[3]*J[8];
    const double d_02 = J[3]*J[7] - J[4]*J[6];
    const double d_10 = J[2]*J[7] - J[1]*J[8];
    const double d_11 = J[0]*J[8] - J[2]*J[6];
    const double d_12 = J[1]*J[6] - J[0]*J[7];
    const double d_20 = J[1]*J[5] - J[2]*J[4];
    const double d_21 = J[2]*J[3] - J[0]*J[5];
    const double d_22 = J[0]*J[4] - J[1]*J[3];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (d_00*(2.0*x[0] - C0) + d_10*(2.0*x[1] - C1) + d_20*(2.0*x[2] - C2)) / detJ;
    double Y = (d_01*(2.0*x[0] - C0) + d_11*(2.0*x[1] - C1) + d_21*(2.0*x[2] - C2)) / detJ;
    double Z = (d_02*(2.0*x[0] - C0) + d_12*(2.0*x[1] - C1) + d_22*(2.0*x[2] - C2)) / detJ;
    
    
    // Reset values
    values[0] = 0.0;
    values[1] = 0.0;
    values[2] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.210818510677892, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.0, 0.223606797749979};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.210818510677892, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.0, 0.223606797749979};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.210818510677892, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.0, 0.223606797749979};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation) const final override
  {
    _evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
  }

  static void _evaluate_basis_all(double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.0, 0.0, 0.0};
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 12; r++)
    {
      _evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation) const final override
  {
    _evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
  }

  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double * values,
                                          const double * x,
                                          const double * coordinate_dofs,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = coordinate_dofs[9]  + coordinate_dofs[6] + coordinate_dofs[3]  - coordinate_dofs[0];
    const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4]  - coordinate_dofs[1];
    const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5]  - coordinate_dofs[2];
    
    // Compute subdeterminants
    const double d_00 = J[4]*J[8] - J[5]*J[7];
    const double d_01 = J[5]*J[6] - J[3]*J[8];
    const double d_02 = J[3]*J[7] - J[4]*J[6];
    const double d_10 = J[2]*J[7] - J[1]*J[8];
    const double d_11 = J[0]*J[8] - J[2]*J[6];
    const double d_12 = J[1]*J[6] - J[0]*J[7];
    const double d_20 = J[1]*J[5] - J[2]*J[4];
    const double d_21 = J[2]*J[3] - J[0]*J[5];
    const double d_22 = J[0]*J[4] - J[1]*J[3];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (d_00*(2.0*x[0] - C0) + d_10*(2.0*x[1] - C1) + d_20*(2.0*x[2] - C2)) / detJ;
    double Y = (d_01*(2.0*x[0] - C0) + d_11*(2.0*x[1] - C1) + d_21*(2.0*x[2] - C2)) / detJ;
    double Z = (d_02*(2.0*x[0] - C0) + d_12*(2.0*x[1] - C1) + d_22*(2.0*x[2] - C2)) / detJ;
    
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[3][1];
    for (unsigned int row = 0; row < 3; row++)
    {
      for (unsigned int col = 0; col < 1; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 2)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[3][3] = {{K[0], K[1], K[2]}, {K[3], K[4], K[5]}, {K[6], K[7], K[8]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[3][3];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.210818510677892, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.0, 0.223606797749979};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.210818510677892, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.0, 0.223606797749979};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.210818510677892, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.0, 0.223606797749979};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    }
    
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation) const final override
  {
    _evaluate_basis_derivatives(i, n, values, x, coordinate_dofs, cell_orientation);
  }

  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double * values,
                                              const double * x,
                                              const double * coordinate_dofs,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 12; r++)
    {
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[9];
    for (unsigned int r = 0; r < 9; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 12; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation) const final override
  {
    _evaluate_basis_derivatives_all(n, values, x, coordinate_dofs, cell_orientation);
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c) const final override
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
      {
        y[0] = coordinate_dofs[0];
      y[1] = coordinate_dofs[1];
      y[2] = coordinate_dofs[2];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = coordinate_dofs[3];
      y[1] = coordinate_dofs[4];
      y[2] = coordinate_dofs[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = coordinate_dofs[6];
      y[1] = coordinate_dofs[7];
      y[2] = coordinate_dofs[8];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = coordinate_dofs[9];
      y[1] = coordinate_dofs[10];
      y[2] = coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = coordinate_dofs[0];
      y[1] = coordinate_dofs[1];
      y[2] = coordinate_dofs[2];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 5:
      {
        y[0] = coordinate_dofs[3];
      y[1] = coordinate_dofs[4];
      y[2] = coordinate_dofs[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 6:
      {
        y[0] = coordinate_dofs[6];
      y[1] = coordinate_dofs[7];
      y[2] = coordinate_dofs[8];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = coordinate_dofs[9];
      y[1] = coordinate_dofs[10];
      y[2] = coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = coordinate_dofs[0];
      y[1] = coordinate_dofs[1];
      y[2] = coordinate_dofs[2];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 9:
      {
        y[0] = coordinate_dofs[3];
      y[1] = coordinate_dofs[4];
      y[2] = coordinate_dofs[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 10:
      {
        y[0] = coordinate_dofs[6];
      y[1] = coordinate_dofs[7];
      y[2] = coordinate_dofs[8];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 11:
      {
        y[0] = coordinate_dofs[9];
      y[1] = coordinate_dofs[10];
      y[2] = coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c) const final override
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[3];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[4] = vals[1];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[8] = vals[2];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[9] = vals[2];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[10] = vals[2];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[11] = vals[2];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::cell& c) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    vertex_values[9] = dof_values[3];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[4];
    vertex_values[4] = dof_values[5];
    vertex_values[7] = dof_values[6];
    vertex_values[10] = dof_values[7];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[8];
    vertex_values[5] = dof_values[9];
    vertex_values[8] = dof_values[10];
    vertex_values[11] = dof_values[11];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs) const final override
  {
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[3] = coordinate_dofs[3];
    dof_coordinates[4] = coordinate_dofs[4];
    dof_coordinates[5] = coordinate_dofs[5];
    dof_coordinates[6] = coordinate_dofs[6];
    dof_coordinates[7] = coordinate_dofs[7];
    dof_coordinates[8] = coordinate_dofs[8];
    dof_coordinates[9] = coordinate_dofs[9];
    dof_coordinates[10] = coordinate_dofs[10];
    dof_coordinates[11] = coordinate_dofs[11];
    dof_coordinates[12] = coordinate_dofs[0];
    dof_coordinates[13] = coordinate_dofs[1];
    dof_coordinates[14] = coordinate_dofs[2];
    dof_coordinates[15] = coordinate_dofs[3];
    dof_coordinates[16] = coordinate_dofs[4];
    dof_coordinates[17] = coordinate_dofs[5];
    dof_coordinates[18] = coordinate_dofs[6];
    dof_coordinates[19] = coordinate_dofs[7];
    dof_coordinates[20] = coordinate_dofs[8];
    dof_coordinates[21] = coordinate_dofs[9];
    dof_coordinates[22] = coordinate_dofs[10];
    dof_coordinates[23] = coordinate_dofs[11];
    dof_coordinates[24] = coordinate_dofs[0];
    dof_coordinates[25] = coordinate_dofs[1];
    dof_coordinates[26] = coordinate_dofs[2];
    dof_coordinates[27] = coordinate_dofs[3];
    dof_coordinates[28] = coordinate_dofs[4];
    dof_coordinates[29] = coordinate_dofs[5];
    dof_coordinates[30] = coordinate_dofs[6];
    dof_coordinates[31] = coordinate_dofs[7];
    dof_coordinates[32] = coordinate_dofs[8];
    dof_coordinates[33] = coordinate_dofs[9];
    dof_coordinates[34] = coordinate_dofs[10];
    dof_coordinates[35] = coordinate_dofs[11];
  }

  std::size_t num_sub_elements() const final override
  {
    return 3;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 1:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 2:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    }
    
    return 0;
  }

  ufc::finite_element * create() const final override
  {
    return new pnp_and_source_finite_element_1();
  }

};


class pnp_and_source_finite_element_2: public ufc::finite_element
{
public:

  pnp_and_source_finite_element_2() : ufc::finite_element()
  {
    // Do nothing
  }

  ~pnp_and_source_finite_element_2() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "MixedElement(FiniteElement('Lagrange', tetrahedron, 1), FiniteElement('Lagrange', tetrahedron, 1), FiniteElement('Lagrange', tetrahedron, 1))";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::tetrahedron;
  }

  std::size_t topological_dimension() const final override
  {
    return 3;
  }

  std::size_t geometric_dimension() const final override
  {
    return 3;
  }

  std::size_t space_dimension() const final override
  {
    return 12;
  }

  std::size_t value_rank() const final override
  {
    return 1;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  std::size_t value_size() const final override
  {
    return 3;
  }

  std::size_t reference_value_rank() const final override
  {
    return 1;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  std::size_t reference_value_size() const final override
  {
    return 3;
  }

  std::size_t degree() const final override
  {
    return 1;
  }

  const char * family() const final override
  {
    return "Mixed";
  }

  static void _evaluate_basis(std::size_t i,
                              double * values,
                              const double * x,
                              const double * coordinate_dofs,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = coordinate_dofs[9]  + coordinate_dofs[6] + coordinate_dofs[3]  - coordinate_dofs[0];
    const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4]  - coordinate_dofs[1];
    const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5]  - coordinate_dofs[2];
    
    // Compute subdeterminants
    const double d_00 = J[4]*J[8] - J[5]*J[7];
    const double d_01 = J[5]*J[6] - J[3]*J[8];
    const double d_02 = J[3]*J[7] - J[4]*J[6];
    const double d_10 = J[2]*J[7] - J[1]*J[8];
    const double d_11 = J[0]*J[8] - J[2]*J[6];
    const double d_12 = J[1]*J[6] - J[0]*J[7];
    const double d_20 = J[1]*J[5] - J[2]*J[4];
    const double d_21 = J[2]*J[3] - J[0]*J[5];
    const double d_22 = J[0]*J[4] - J[1]*J[3];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (d_00*(2.0*x[0] - C0) + d_10*(2.0*x[1] - C1) + d_20*(2.0*x[2] - C2)) / detJ;
    double Y = (d_01*(2.0*x[0] - C0) + d_11*(2.0*x[1] - C1) + d_21*(2.0*x[2] - C2)) / detJ;
    double Z = (d_02*(2.0*x[0] - C0) + d_12*(2.0*x[1] - C1) + d_22*(2.0*x[2] - C2)) / detJ;
    
    
    // Reset values
    values[0] = 0.0;
    values[1] = 0.0;
    values[2] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.210818510677892, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.0, 0.223606797749979};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.210818510677892, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.0, 0.223606797749979};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.210818510677892, -0.074535599249993};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.0, 0.223606797749979};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 4; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation) const final override
  {
    _evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
  }

  static void _evaluate_basis_all(double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.0, 0.0, 0.0};
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 12; r++)
    {
      _evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation) const final override
  {
    _evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
  }

  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double * values,
                                          const double * x,
                                          const double * coordinate_dofs,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = coordinate_dofs[9]  + coordinate_dofs[6] + coordinate_dofs[3]  - coordinate_dofs[0];
    const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4]  - coordinate_dofs[1];
    const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5]  - coordinate_dofs[2];
    
    // Compute subdeterminants
    const double d_00 = J[4]*J[8] - J[5]*J[7];
    const double d_01 = J[5]*J[6] - J[3]*J[8];
    const double d_02 = J[3]*J[7] - J[4]*J[6];
    const double d_10 = J[2]*J[7] - J[1]*J[8];
    const double d_11 = J[0]*J[8] - J[2]*J[6];
    const double d_12 = J[1]*J[6] - J[0]*J[7];
    const double d_20 = J[1]*J[5] - J[2]*J[4];
    const double d_21 = J[2]*J[3] - J[0]*J[5];
    const double d_22 = J[0]*J[4] - J[1]*J[3];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (d_00*(2.0*x[0] - C0) + d_10*(2.0*x[1] - C1) + d_20*(2.0*x[2] - C2)) / detJ;
    double Y = (d_01*(2.0*x[0] - C0) + d_11*(2.0*x[1] - C1) + d_21*(2.0*x[2] - C2)) / detJ;
    double Z = (d_02*(2.0*x[0] - C0) + d_12*(2.0*x[1] - C1) + d_22*(2.0*x[2] - C2)) / detJ;
    
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[3][1];
    for (unsigned int row = 0; row < 3; row++)
    {
      for (unsigned int col = 0; col < 1; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 2)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[3][3] = {{K[0], K[1], K[2]}, {K[3], K[4], K[5]}, {K[6], K[7], K[8]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[3][3];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.210818510677892, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.0, 0.223606797749979};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.210818510677892, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.0, 0.223606797749979};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, -0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.182574185835055, -0.105409255338946, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.210818510677892, -0.074535599249993};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[4] = {0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = 0.5*(2.0 + Y + Z + 2.0*X);
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = 0.5*(2.0 + 3.0*Y + Z)*basisvalues[0];
      basisvalues[3] = (2.0*Z + 1.0)*basisvalues[0];
      basisvalues[0] *= std::sqrt(0.75);
      basisvalues[3] *= std::sqrt(1.25);
      basisvalues[2] *= std::sqrt(2.5);
      basisvalues[1] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[4] = \
      {0.288675134594813, 0.0, 0.0, 0.223606797749979};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {6.32455532033676, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {5.47722557505166, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats2[4][4] = \
      {{0.0, 0.0, 0.0, 0.0},
      {3.16227766016838, 0.0, 0.0, 0.0},
      {1.82574185835055, 0.0, 0.0, 0.0},
      {5.16397779494322, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[3];
      for (unsigned int r = 0; r < 3; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[4][4] = \
      {{1.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 4; t++)
        {
          for (unsigned int u = 0; u < 4; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 2)
          {
          for (unsigned int t = 0; t < 4; t++)
          {
            for (unsigned int u = 0; u < 4; u++)
            {
              for (unsigned int tu = 0; tu < 4; tu++)
              {
                dmats[t][u] += dmats2[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 4; s++)
        {
          for (unsigned int t = 0; t < 4; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    }
    
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation) const final override
  {
    _evaluate_basis_derivatives(i, n, values, x, coordinate_dofs, cell_orientation);
  }

  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double * values,
                                              const double * x,
                                              const double * coordinate_dofs,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 12; r++)
    {
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[9];
    for (unsigned int r = 0; r < 9; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 12; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation) const final override
  {
    _evaluate_basis_derivatives_all(n, values, x, coordinate_dofs, cell_orientation);
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c) const final override
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
      {
        y[0] = coordinate_dofs[0];
      y[1] = coordinate_dofs[1];
      y[2] = coordinate_dofs[2];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = coordinate_dofs[3];
      y[1] = coordinate_dofs[4];
      y[2] = coordinate_dofs[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = coordinate_dofs[6];
      y[1] = coordinate_dofs[7];
      y[2] = coordinate_dofs[8];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = coordinate_dofs[9];
      y[1] = coordinate_dofs[10];
      y[2] = coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = coordinate_dofs[0];
      y[1] = coordinate_dofs[1];
      y[2] = coordinate_dofs[2];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 5:
      {
        y[0] = coordinate_dofs[3];
      y[1] = coordinate_dofs[4];
      y[2] = coordinate_dofs[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 6:
      {
        y[0] = coordinate_dofs[6];
      y[1] = coordinate_dofs[7];
      y[2] = coordinate_dofs[8];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = coordinate_dofs[9];
      y[1] = coordinate_dofs[10];
      y[2] = coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = coordinate_dofs[0];
      y[1] = coordinate_dofs[1];
      y[2] = coordinate_dofs[2];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 9:
      {
        y[0] = coordinate_dofs[3];
      y[1] = coordinate_dofs[4];
      y[2] = coordinate_dofs[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 10:
      {
        y[0] = coordinate_dofs[6];
      y[1] = coordinate_dofs[7];
      y[2] = coordinate_dofs[8];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 11:
      {
        y[0] = coordinate_dofs[9];
      y[1] = coordinate_dofs[10];
      y[2] = coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c) const final override
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[3];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[4] = vals[1];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[8] = vals[2];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[9] = vals[2];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[10] = vals[2];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[11] = vals[2];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::cell& c) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    vertex_values[9] = dof_values[3];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[4];
    vertex_values[4] = dof_values[5];
    vertex_values[7] = dof_values[6];
    vertex_values[10] = dof_values[7];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[8];
    vertex_values[5] = dof_values[9];
    vertex_values[8] = dof_values[10];
    vertex_values[11] = dof_values[11];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs) const final override
  {
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[3] = coordinate_dofs[3];
    dof_coordinates[4] = coordinate_dofs[4];
    dof_coordinates[5] = coordinate_dofs[5];
    dof_coordinates[6] = coordinate_dofs[6];
    dof_coordinates[7] = coordinate_dofs[7];
    dof_coordinates[8] = coordinate_dofs[8];
    dof_coordinates[9] = coordinate_dofs[9];
    dof_coordinates[10] = coordinate_dofs[10];
    dof_coordinates[11] = coordinate_dofs[11];
    dof_coordinates[12] = coordinate_dofs[0];
    dof_coordinates[13] = coordinate_dofs[1];
    dof_coordinates[14] = coordinate_dofs[2];
    dof_coordinates[15] = coordinate_dofs[3];
    dof_coordinates[16] = coordinate_dofs[4];
    dof_coordinates[17] = coordinate_dofs[5];
    dof_coordinates[18] = coordinate_dofs[6];
    dof_coordinates[19] = coordinate_dofs[7];
    dof_coordinates[20] = coordinate_dofs[8];
    dof_coordinates[21] = coordinate_dofs[9];
    dof_coordinates[22] = coordinate_dofs[10];
    dof_coordinates[23] = coordinate_dofs[11];
    dof_coordinates[24] = coordinate_dofs[0];
    dof_coordinates[25] = coordinate_dofs[1];
    dof_coordinates[26] = coordinate_dofs[2];
    dof_coordinates[27] = coordinate_dofs[3];
    dof_coordinates[28] = coordinate_dofs[4];
    dof_coordinates[29] = coordinate_dofs[5];
    dof_coordinates[30] = coordinate_dofs[6];
    dof_coordinates[31] = coordinate_dofs[7];
    dof_coordinates[32] = coordinate_dofs[8];
    dof_coordinates[33] = coordinate_dofs[9];
    dof_coordinates[34] = coordinate_dofs[10];
    dof_coordinates[35] = coordinate_dofs[11];
  }

  std::size_t num_sub_elements() const final override
  {
    return 3;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 1:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 2:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    }
    
    return 0;
  }

  ufc::finite_element * create() const final override
  {
    return new pnp_and_source_finite_element_2();
  }

};


class pnp_and_source_finite_element_3: public ufc::finite_element
{
public:

  pnp_and_source_finite_element_3() : ufc::finite_element()
  {
    // Do nothing
  }

  ~pnp_and_source_finite_element_3() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FiniteElement('Real', tetrahedron, 0)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::tetrahedron;
  }

  std::size_t topological_dimension() const final override
  {
    return 3;
  }

  std::size_t geometric_dimension() const final override
  {
    return 3;
  }

  std::size_t space_dimension() const final override
  {
    return 1;
  }

  std::size_t value_rank() const final override
  {
    return 0;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t value_size() const final override
  {
    return 1;
  }

  std::size_t reference_value_rank() const final override
  {
    return 0;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t reference_value_size() const final override
  {
    return 1;
  }

  std::size_t degree() const final override
  {
    return 0;
  }

  const char * family() const final override
  {
    return "Real";
  }

  static void _evaluate_basis(std::size_t i,
                              double * values,
                              const double * x,
                              const double * coordinate_dofs,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    
    // Compute constants
    
    // Compute subdeterminants
    
    // Get coordinates and map to the reference (FIAT) element
    
    
    // Reset values
    *values = 0.0;
    
    // Array of basisvalues
    double basisvalues[1] = {0.0};
    
    // Declare helper variables
    
    // Compute basisvalues
    basisvalues[0] = 1.0;
    
    // Table(s) of coefficients
    static const double coefficients0[1] = \
    {1.0};
    
    // Compute value(s)
    for (unsigned int r = 0; r < 1; r++)
    {
      *values += coefficients0[r]*basisvalues[r];
    } // end loop over 'r'
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation) const final override
  {
    _evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
  }

  static void _evaluate_basis_all(double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation)
  {
    // Element is constant, calling evaluate_basis.
    _evaluate_basis(0, values, x, coordinate_dofs, cell_orientation);
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation) const final override
  {
    _evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
  }

  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double * values,
                                          const double * x,
                                          const double * coordinate_dofs,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 3;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 0)
    {
    return ;
    }
    
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation) const final override
  {
    _evaluate_basis_derivatives(i, n, values, x, coordinate_dofs, cell_orientation);
  }

  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double * values,
                                              const double * x,
                                              const double * coordinate_dofs,
                                              int cell_orientation)
  {
    // Element is constant, calling evaluate_basis_derivatives.
    _evaluate_basis_derivatives(0, n, values, x, coordinate_dofs, cell_orientation);
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation) const final override
  {
    _evaluate_basis_derivatives_all(n, values, x, coordinate_dofs, cell_orientation);
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
      {
        y[0] = 0.25*coordinate_dofs[0] + 0.25*coordinate_dofs[3] + 0.25*coordinate_dofs[6] + 0.25*coordinate_dofs[9];
      y[1] = 0.25*coordinate_dofs[1] + 0.25*coordinate_dofs[4] + 0.25*coordinate_dofs[7] + 0.25*coordinate_dofs[10];
      y[2] = 0.25*coordinate_dofs[2] + 0.25*coordinate_dofs[5] + 0.25*coordinate_dofs[8] + 0.25*coordinate_dofs[11];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[3];
    y[0] = 0.25*coordinate_dofs[0] + 0.25*coordinate_dofs[3] + 0.25*coordinate_dofs[6] + 0.25*coordinate_dofs[9];
    y[1] = 0.25*coordinate_dofs[1] + 0.25*coordinate_dofs[4] + 0.25*coordinate_dofs[7] + 0.25*coordinate_dofs[10];
    y[2] = 0.25*coordinate_dofs[2] + 0.25*coordinate_dofs[5] + 0.25*coordinate_dofs[8] + 0.25*coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::cell& c) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
    vertex_values[2] = dof_values[0];
    vertex_values[3] = dof_values[0];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs) const final override
  {
    dof_coordinates[0] = 0.25*coordinate_dofs[0] + 0.25*coordinate_dofs[3] + 0.25*coordinate_dofs[6] + 0.25*coordinate_dofs[9];
    dof_coordinates[1] = 0.25*coordinate_dofs[1] + 0.25*coordinate_dofs[4] + 0.25*coordinate_dofs[7] + 0.25*coordinate_dofs[10];
    dof_coordinates[2] = 0.25*coordinate_dofs[2] + 0.25*coordinate_dofs[5] + 0.25*coordinate_dofs[8] + 0.25*coordinate_dofs[11];
  }

  std::size_t num_sub_elements() const final override
  {
    return 0;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    return 0;
  }

  ufc::finite_element * create() const final override
  {
    return new pnp_and_source_finite_element_3();
  }

};


class pnp_and_source_dofmap_0: public ufc::dofmap
{
public:

  pnp_and_source_dofmap_0() : ufc::dofmap()
  {
    // Do nothing
  }

  ~pnp_and_source_dofmap_0() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for FiniteElement('Lagrange', tetrahedron, 1)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    case 3:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  std::size_t topological_dimension() const final override
  {
    return 3;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return num_global_entities[0];
  }

  std::size_t num_element_dofs() const final override
  {
    return 4;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 3;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    case 3:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    dofs[0] = entity_indices[0][0];
    dofs[1] = entity_indices[0][1];
    dofs[2] = entity_indices[0][2];
    dofs[3] = entity_indices[0][3];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 3;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 3;
        break;
      }
    case 3:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
        break;
      }
    }
    
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    if (d > 3)
    {
    throw std::runtime_error("d is larger than dimension (3)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 3)
      {
      throw std::runtime_error("i is larger than number of entities (3)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      case 3:
        {
          dofs[0] = 3;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    case 3:
      {
        
        break;
      }
    }
    
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 0;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    return 0;
  }

  ufc::dofmap * create() const final override
  {
    return new pnp_and_source_dofmap_0();
  }

};


class pnp_and_source_dofmap_1: public ufc::dofmap
{
public:

  pnp_and_source_dofmap_1() : ufc::dofmap()
  {
    // Do nothing
  }

  ~pnp_and_source_dofmap_1() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for VectorElement(FiniteElement('Lagrange', tetrahedron, 1), dim=3)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    case 3:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  std::size_t topological_dimension() const final override
  {
    return 3;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 3*num_global_entities[0];
  }

  std::size_t num_element_dofs() const final override
  {
    return 12;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 9;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    switch (d)
    {
    case 0:
      {
        return 3;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    case 3:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    unsigned int offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    dofs[3] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[4] = offset + entity_indices[0][0];
    dofs[5] = offset + entity_indices[0][1];
    dofs[6] = offset + entity_indices[0][2];
    dofs[7] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[8] = offset + entity_indices[0][0];
    dofs[9] = offset + entity_indices[0][1];
    dofs[10] = offset + entity_indices[0][2];
    dofs[11] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 5;
      dofs[4] = 6;
      dofs[5] = 7;
      dofs[6] = 9;
      dofs[7] = 10;
      dofs[8] = 11;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 6;
      dofs[5] = 7;
      dofs[6] = 8;
      dofs[7] = 10;
      dofs[8] = 11;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 5;
      dofs[5] = 7;
      dofs[6] = 8;
      dofs[7] = 9;
      dofs[8] = 11;
        break;
      }
    case 3:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      dofs[3] = 4;
      dofs[4] = 5;
      dofs[5] = 6;
      dofs[6] = 8;
      dofs[7] = 9;
      dofs[8] = 10;
        break;
      }
    }
    
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    if (d > 3)
    {
    throw std::runtime_error("d is larger than dimension (3)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 3)
      {
      throw std::runtime_error("i is larger than number of entities (3)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 4;
        dofs[2] = 8;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 5;
        dofs[2] = 9;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 6;
        dofs[2] = 10;
          break;
        }
      case 3:
        {
          dofs[0] = 3;
        dofs[1] = 7;
        dofs[2] = 11;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    case 3:
      {
        
        break;
      }
    }
    
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 3;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 1:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 2:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    }
    
    return 0;
  }

  ufc::dofmap * create() const final override
  {
    return new pnp_and_source_dofmap_1();
  }

};


class pnp_and_source_dofmap_2: public ufc::dofmap
{
public:

  pnp_and_source_dofmap_2() : ufc::dofmap()
  {
    // Do nothing
  }

  ~pnp_and_source_dofmap_2() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for MixedElement(FiniteElement('Lagrange', tetrahedron, 1), FiniteElement('Lagrange', tetrahedron, 1), FiniteElement('Lagrange', tetrahedron, 1))";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    case 3:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  std::size_t topological_dimension() const final override
  {
    return 3;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 3*num_global_entities[0];
  }

  std::size_t num_element_dofs() const final override
  {
    return 12;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 9;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    switch (d)
    {
    case 0:
      {
        return 3;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    case 3:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    unsigned int offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    dofs[3] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[4] = offset + entity_indices[0][0];
    dofs[5] = offset + entity_indices[0][1];
    dofs[6] = offset + entity_indices[0][2];
    dofs[7] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[8] = offset + entity_indices[0][0];
    dofs[9] = offset + entity_indices[0][1];
    dofs[10] = offset + entity_indices[0][2];
    dofs[11] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 5;
      dofs[4] = 6;
      dofs[5] = 7;
      dofs[6] = 9;
      dofs[7] = 10;
      dofs[8] = 11;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 6;
      dofs[5] = 7;
      dofs[6] = 8;
      dofs[7] = 10;
      dofs[8] = 11;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 5;
      dofs[5] = 7;
      dofs[6] = 8;
      dofs[7] = 9;
      dofs[8] = 11;
        break;
      }
    case 3:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      dofs[3] = 4;
      dofs[4] = 5;
      dofs[5] = 6;
      dofs[6] = 8;
      dofs[7] = 9;
      dofs[8] = 10;
        break;
      }
    }
    
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    if (d > 3)
    {
    throw std::runtime_error("d is larger than dimension (3)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 3)
      {
      throw std::runtime_error("i is larger than number of entities (3)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 4;
        dofs[2] = 8;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 5;
        dofs[2] = 9;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 6;
        dofs[2] = 10;
          break;
        }
      case 3:
        {
          dofs[0] = 3;
        dofs[1] = 7;
        dofs[2] = 11;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    case 3:
      {
        
        break;
      }
    }
    
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 3;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 1:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 2:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    }
    
    return 0;
  }

  ufc::dofmap * create() const final override
  {
    return new pnp_and_source_dofmap_2();
  }

};


class pnp_and_source_dofmap_3: public ufc::dofmap
{
public:

  pnp_and_source_dofmap_3() : ufc::dofmap()
  {
    // Do nothing
  }

  ~pnp_and_source_dofmap_3() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for FiniteElement('Real', tetrahedron, 0)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    case 3:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  std::size_t topological_dimension() const final override
  {
    return 3;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 1;
  }

  std::size_t num_element_dofs() const final override
  {
    return 1;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 0;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    case 3:
      {
        return 1;
        break;
      }
    }
    
    return 0;
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    dofs[0] = 0;
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    case 3:
      {
        
        break;
      }
    }
    
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    if (d > 3)
    {
    throw std::runtime_error("d is larger than dimension (3)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    case 3:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
        break;
      }
    }
    
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 0;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    return 0;
  }

  ufc::dofmap * create() const final override
  {
    return new pnp_and_source_dofmap_3();
  }

};


class pnp_and_source_cell_integral_0_otherwise: public ufc::cell_integral
{
public:

  pnp_and_source_cell_integral_0_otherwise() : ufc::cell_integral()
  {
    
  }

  ~pnp_and_source_cell_integral_0_otherwise() override
  {
    
  }

  const std::vector<bool> & enabled_coefficients() const final override
  {
    static const std::vector<bool> enabled({true, true, true, true, true, true, true, true});
    return enabled;
  }

  void tabulate_tensor(double * A,
                       const double * const * w,
                       const double * coordinate_dofs,
                       int cell_orientation) const final override
  {
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W15[15] = {0.0302836780970892, 0.00602678571428572, 0.00602678571428572, 0.00602678571428572, 0.00602678571428572, 0.011645249086029, 0.011645249086029, 0.011645249086029, 0.011645249086029, 0.0109491415613864, 0.0109491415613864, 0.0109491415613864, 0.0109491415613864, 0.0109491415613864, 0.0109491415613864};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.0, 0.333333333333333, 0.333333333333333), (0.333333333333333, 0.333333333333333, 0.333333333333333), (0.333333333333333, 0.333333333333333, 0.0), (0.333333333333333, 0.0, 0.333333333333333), (0.727272727272727, 0.0909090909090909, 0.0909090909090909), (0.0909090909090909, 0.0909090909090909, 0.0909090909090909), (0.0909090909090909, 0.0909090909090909, 0.727272727272727), (0.0909090909090909, 0.727272727272727, 0.0909090909090909), (0.433449846426336, 0.0665501535736643, 0.0665501535736643), (0.0665501535736643, 0.433449846426336, 0.0665501535736643), (0.0665501535736643, 0.0665501535736643, 0.433449846426336), (0.0665501535736643, 0.433449846426336, 0.433449846426336), (0.433449846426336, 0.0665501535736643, 0.433449846426336), (0.433449846426336, 0.433449846426336, 0.0665501535736643)
    
    // Values of basis functions at quadrature points.
    static const double FE0[15][4] = \
    {{0.25, 0.25, 0.25, 0.25},
    {0.333333333333333, 0.0, 0.333333333333333, 0.333333333333333},
    {0.0, 0.333333333333333, 0.333333333333333, 0.333333333333333},
    {0.333333333333333, 0.333333333333333, 0.333333333333333, 0.0},
    {0.333333333333333, 0.333333333333333, 0.0, 0.333333333333333},
    {0.090909090909091, 0.727272727272727, 0.0909090909090909, 0.0909090909090909},
    {0.727272727272727, 0.0909090909090908, 0.0909090909090909, 0.0909090909090909},
    {0.0909090909090909, 0.0909090909090909, 0.0909090909090909, 0.727272727272727},
    {0.090909090909091, 0.0909090909090908, 0.727272727272727, 0.0909090909090909},
    {0.433449846426336, 0.433449846426336, 0.0665501535736643, 0.0665501535736643},
    {0.433449846426336, 0.0665501535736643, 0.433449846426336, 0.0665501535736643},
    {0.433449846426336, 0.0665501535736643, 0.0665501535736643, 0.433449846426336},
    {0.0665501535736644, 0.0665501535736643, 0.433449846426336, 0.433449846426336},
    {0.0665501535736644, 0.433449846426336, 0.0665501535736643, 0.433449846426336},
    {0.0665501535736643, 0.433449846426336, 0.433449846426336, 0.0665501535736643}};
    
    // Array of non-zero columns
    static const unsigned int nzc3[4] = {0, 1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc7[4] = {4, 5, 6, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc11[4] = {8, 9, 10, 11};
    
    static const double FE0_D001[15][2] = \
    {{-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc4[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc5[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc6[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc8[2] = {4, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc9[2] = {4, 6};
    
    // Array of non-zero columns
    static const unsigned int nzc10[2] = {4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc12[2] = {8, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc13[2] = {8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc14[2] = {8, 9};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 144; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 122.
    double G[20];
    G[0] = det*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]);
    G[1] = det*w[7][0]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]);
    G[2] = det*w[7][0]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]);
    G[3] = det*w[7][0]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]);
    G[4] = det*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]);
    G[5] = det*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]);
    G[6] = det*(K[6]*K[6] + K[7]*K[7] + K[8]*K[8]);
    G[7] = det*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8]);
    G[8] = det*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]);
    G[9] = det*w[5][0]*(K[6]*K[6] + K[7]*K[7] + K[8]*K[8]);
    G[10] = det*w[5][0]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8]);
    G[11] = det*w[5][0]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]);
    G[12] = det*w[5][0]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]);
    G[13] = det*w[5][0]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]);
    G[14] = det*w[5][0]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]);
    G[15] = det*w[7][0]*(K[6]*K[6] + K[7]*K[7] + K[8]*K[8]);
    G[16] = det*w[7][0]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8]);
    G[17] = det*w[7][0]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]);
    G[18] =  - det*w[5][0];
    G[19] =  - det*w[7][0];
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 15900
    for (unsigned int ip = 0; ip < 15; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      double F10 = 0.0;
      double F11 = 0.0;
      double F12 = 0.0;
      double F13 = 0.0;
      
      // Total number of operations to compute function values = 36
      for (unsigned int r = 0; r < 2; r++)
      {
        F2 += FE0_D001[ip][r]*w[2][nzc2[r]];
        F3 += FE0_D001[ip][r]*w[2][nzc1[r]];
        F4 += FE0_D001[ip][r]*w[2][nzc0[r]];
        F5 += FE0_D001[ip][r]*w[0][nzc2[r]];
        F6 += FE0_D001[ip][r]*w[0][nzc1[r]];
        F7 += FE0_D001[ip][r]*w[0][nzc0[r]];
        F9 += FE0_D001[ip][r]*w[1][nzc2[r]];
        F10 += FE0_D001[ip][r]*w[1][nzc1[r]];
        F11 += FE0_D001[ip][r]*w[1][nzc0[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 40
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0[ip][r]*w[0][r];
        F1 += FE0[ip][r]*w[1][r];
        F8 += FE0[ip][r]*w[4][r];
        F12 += FE0[ip][r]*w[6][r];
        F13 += FE0[ip][r]*w[3][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 204
      double I[38];
      // Number of operations: 4
      I[0] = F12*G[0]*W15[ip]*std::exp(F1);
      
      // Number of operations: 4
      I[1] = F12*G[1]*W15[ip]*std::exp(F1);
      
      // Number of operations: 4
      I[2] = F12*G[2]*W15[ip]*std::exp(F1);
      
      // Number of operations: 4
      I[3] = F12*G[3]*W15[ip]*std::exp(F1);
      
      // Number of operations: 4
      I[4] = F12*G[4]*W15[ip]*std::exp(F1);
      
      // Number of operations: 4
      I[5] = F12*G[5]*W15[ip]*std::exp(F1);
      
      // Number of operations: 2
      I[6] = F13*G[6]*W15[ip];
      
      // Number of operations: 2
      I[7] = F13*G[7]*W15[ip];
      
      // Number of operations: 2
      I[8] = F13*G[4]*W15[ip];
      
      // Number of operations: 2
      I[9] = F13*G[8]*W15[ip];
      
      // Number of operations: 2
      I[10] = F13*G[5]*W15[ip];
      
      // Number of operations: 2
      I[11] = F13*G[0]*W15[ip];
      
      // Number of operations: 4
      I[12] = F8*G[9]*W15[ip]*std::exp(F0);
      
      // Number of operations: 4
      I[13] = F8*G[10]*W15[ip]*std::exp(F0);
      
      // Number of operations: 4
      I[14] = F8*G[11]*W15[ip]*std::exp(F0);
      
      // Number of operations: 4
      I[15] = F8*G[6]*W15[ip]*std::exp(F0);
      
      // Number of operations: 4
      I[16] = F8*G[7]*W15[ip]*std::exp(F0);
      
      // Number of operations: 4
      I[17] = F8*G[4]*W15[ip]*std::exp(F0);
      
      // Number of operations: 4
      I[18] = F8*G[12]*W15[ip]*std::exp(F0);
      
      // Number of operations: 4
      I[19] = F8*G[13]*W15[ip]*std::exp(F0);
      
      // Number of operations: 4
      I[20] = F8*G[8]*W15[ip]*std::exp(F0);
      
      // Number of operations: 4
      I[21] = F8*G[5]*W15[ip]*std::exp(F0);
      
      // Number of operations: 4
      I[22] = F8*G[14]*W15[ip]*std::exp(F0);
      
      // Number of operations: 4
      I[23] = F8*G[0]*W15[ip]*std::exp(F0);
      
      // Number of operations: 4
      I[24] = F12*G[15]*W15[ip]*std::exp(F1);
      
      // Number of operations: 4
      I[25] = F12*G[16]*W15[ip]*std::exp(F1);
      
      // Number of operations: 4
      I[26] = F12*G[6]*W15[ip]*std::exp(F1);
      
      // Number of operations: 4
      I[27] = F12*G[7]*W15[ip]*std::exp(F1);
      
      // Number of operations: 4
      I[28] = F12*G[17]*W15[ip]*std::exp(F1);
      
      // Number of operations: 4
      I[29] = F12*G[8]*W15[ip]*std::exp(F1);
      
      // Number of operations: 15
      I[30] = F12*W15[ip]*std::exp(F1)*(F10*G[5] + F11*G[4] + F2*G[3] + F3*G[2] + F4*G[1] + F9*G[0]);
      
      // Number of operations: 15
      I[31] = F8*W15[ip]*std::exp(F0)*(F2*G[11] + F3*G[10] + F4*G[9] + F5*G[4] + F6*G[7] + F7*G[6]);
      
      // Number of operations: 15
      I[32] = F8*W15[ip]*std::exp(F0)*(F2*G[13] + F3*G[12] + F4*G[10] + F5*G[5] + F6*G[8] + F7*G[7]);
      
      // Number of operations: 15
      I[33] = F8*W15[ip]*std::exp(F0)*(F2*G[14] + F3*G[13] + F4*G[11] + F5*G[0] + F6*G[5] + F7*G[4]);
      
      // Number of operations: 15
      I[34] = F12*W15[ip]*std::exp(F1)*(F10*G[7] + F11*G[6] + F2*G[1] + F3*G[16] + F4*G[15] + F9*G[4]);
      
      // Number of operations: 15
      I[35] = F12*W15[ip]*std::exp(F1)*(F10*G[8] + F11*G[7] + F2*G[2] + F3*G[17] + F4*G[16] + F9*G[5]);
      
      // Number of operations: 3
      I[36] = G[18]*W15[ip]*std::exp(F0);
      
      // Number of operations: 3
      I[37] = G[19]*W15[ip]*std::exp(F1);
      
      
      // Number of operations for primary indices: 540
      for (unsigned int j = 0; j < 2; j++)
      {
        for (unsigned int k = 0; k < 2; k++)
        {
          // Number of operations to compute entry: 3
          A[nzc10[j]*12 + nzc10[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc10[j]*12 + nzc12[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[1];
          // Number of operations to compute entry: 3
          A[nzc10[j]*12 + nzc13[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[2];
          // Number of operations to compute entry: 3
          A[nzc10[j]*12 + nzc14[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[3];
          // Number of operations to compute entry: 3
          A[nzc10[j]*12 + nzc8[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[4];
          // Number of operations to compute entry: 3
          A[nzc10[j]*12 + nzc9[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[5];
          // Number of operations to compute entry: 3
          A[nzc12[j]*12 + nzc12[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[6];
          // Number of operations to compute entry: 3
          A[nzc12[j]*12 + nzc13[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[7];
          // Number of operations to compute entry: 3
          A[nzc12[j]*12 + nzc14[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[8];
          // Number of operations to compute entry: 3
          A[nzc13[j]*12 + nzc12[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[7];
          // Number of operations to compute entry: 3
          A[nzc13[j]*12 + nzc13[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[9];
          // Number of operations to compute entry: 3
          A[nzc13[j]*12 + nzc14[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[10];
          // Number of operations to compute entry: 3
          A[nzc14[j]*12 + nzc12[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[8];
          // Number of operations to compute entry: 3
          A[nzc14[j]*12 + nzc13[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[10];
          // Number of operations to compute entry: 3
          A[nzc14[j]*12 + nzc14[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[11];
          // Number of operations to compute entry: 3
          A[nzc4[j]*12 + nzc12[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[12];
          // Number of operations to compute entry: 3
          A[nzc4[j]*12 + nzc13[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[13];
          // Number of operations to compute entry: 3
          A[nzc4[j]*12 + nzc14[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[14];
          // Number of operations to compute entry: 3
          A[nzc4[j]*12 + nzc4[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[15];
          // Number of operations to compute entry: 3
          A[nzc4[j]*12 + nzc5[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[16];
          // Number of operations to compute entry: 3
          A[nzc4[j]*12 + nzc6[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[17];
          // Number of operations to compute entry: 3
          A[nzc5[j]*12 + nzc12[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[13];
          // Number of operations to compute entry: 3
          A[nzc5[j]*12 + nzc13[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[18];
          // Number of operations to compute entry: 3
          A[nzc5[j]*12 + nzc14[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[19];
          // Number of operations to compute entry: 3
          A[nzc5[j]*12 + nzc4[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[16];
          // Number of operations to compute entry: 3
          A[nzc5[j]*12 + nzc5[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[20];
          // Number of operations to compute entry: 3
          A[nzc5[j]*12 + nzc6[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[21];
          // Number of operations to compute entry: 3
          A[nzc6[j]*12 + nzc12[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[14];
          // Number of operations to compute entry: 3
          A[nzc6[j]*12 + nzc13[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[19];
          // Number of operations to compute entry: 3
          A[nzc6[j]*12 + nzc14[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[22];
          // Number of operations to compute entry: 3
          A[nzc6[j]*12 + nzc4[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[17];
          // Number of operations to compute entry: 3
          A[nzc6[j]*12 + nzc5[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[21];
          // Number of operations to compute entry: 3
          A[nzc6[j]*12 + nzc6[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[23];
          // Number of operations to compute entry: 3
          A[nzc8[j]*12 + nzc10[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[4];
          // Number of operations to compute entry: 3
          A[nzc8[j]*12 + nzc12[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[24];
          // Number of operations to compute entry: 3
          A[nzc8[j]*12 + nzc13[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[25];
          // Number of operations to compute entry: 3
          A[nzc8[j]*12 + nzc14[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[1];
          // Number of operations to compute entry: 3
          A[nzc8[j]*12 + nzc8[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[26];
          // Number of operations to compute entry: 3
          A[nzc8[j]*12 + nzc9[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[27];
          // Number of operations to compute entry: 3
          A[nzc9[j]*12 + nzc10[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[5];
          // Number of operations to compute entry: 3
          A[nzc9[j]*12 + nzc12[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[25];
          // Number of operations to compute entry: 3
          A[nzc9[j]*12 + nzc13[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[28];
          // Number of operations to compute entry: 3
          A[nzc9[j]*12 + nzc14[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[2];
          // Number of operations to compute entry: 3
          A[nzc9[j]*12 + nzc8[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[27];
          // Number of operations to compute entry: 3
          A[nzc9[j]*12 + nzc9[k]] += FE0_D001[ip][j]*FE0_D001[ip][k]*I[29];
        } // end loop over 'k'
      } // end loop over 'j'
      
      // Number of operations for primary indices: 144
      for (unsigned int j = 0; j < 2; j++)
      {
        for (unsigned int k = 0; k < 4; k++)
        {
          // Number of operations to compute entry: 3
          A[nzc10[j]*12 + nzc7[k]] += FE0[ip][k]*FE0_D001[ip][j]*I[30];
          // Number of operations to compute entry: 3
          A[nzc4[j]*12 + nzc3[k]] += FE0[ip][k]*FE0_D001[ip][j]*I[31];
          // Number of operations to compute entry: 3
          A[nzc5[j]*12 + nzc3[k]] += FE0[ip][k]*FE0_D001[ip][j]*I[32];
          // Number of operations to compute entry: 3
          A[nzc6[j]*12 + nzc3[k]] += FE0[ip][k]*FE0_D001[ip][j]*I[33];
          // Number of operations to compute entry: 3
          A[nzc8[j]*12 + nzc7[k]] += FE0[ip][k]*FE0_D001[ip][j]*I[34];
          // Number of operations to compute entry: 3
          A[nzc9[j]*12 + nzc7[k]] += FE0[ip][k]*FE0_D001[ip][j]*I[35];
        } // end loop over 'k'
      } // end loop over 'j'
      
      // Number of operations for primary indices: 96
      for (unsigned int j = 0; j < 4; j++)
      {
        for (unsigned int k = 0; k < 4; k++)
        {
          // Number of operations to compute entry: 3
          A[nzc11[j]*12 + nzc3[k]] += FE0[ip][j]*FE0[ip][k]*I[36];
          // Number of operations to compute entry: 3
          A[nzc11[j]*12 + nzc7[k]] += FE0[ip][j]*FE0[ip][k]*I[37];
        } // end loop over 'k'
      } // end loop over 'j'
    } // end loop over 'ip'
  }

};


class pnp_and_source_cell_integral_1_otherwise: public ufc::cell_integral
{
public:

  pnp_and_source_cell_integral_1_otherwise() : ufc::cell_integral()
  {
    
  }

  ~pnp_and_source_cell_integral_1_otherwise() override
  {
    
  }

  const std::vector<bool> & enabled_coefficients() const final override
  {
    static const std::vector<bool> enabled({true, true, true, true, true, true, true, true, true, true, true});
    return enabled;
  }

  void tabulate_tensor(double * A,
                       const double * const * w,
                       const double * coordinate_dofs,
                       int cell_orientation) const final override
  {
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W14[14] = {0.00317460317460317, 0.00317460317460317, 0.00317460317460317, 0.00317460317460317, 0.00317460317460317, 0.00317460317460317, 0.0147649707904968, 0.0147649707904968, 0.0147649707904968, 0.0147649707904968, 0.0221397911142651, 0.0221397911142651, 0.0221397911142651, 0.0221397911142651};
    // Quadrature points on the UFC reference element: (0.0, 0.5, 0.5), (0.5, 0.0, 0.5), (0.5, 0.5, 0.0), (0.5, 0.0, 0.0), (0.0, 0.5, 0.0), (0.0, 0.0, 0.5), (0.698419704324387, 0.100526765225204, 0.100526765225204), (0.100526765225204, 0.100526765225204, 0.100526765225204), (0.100526765225204, 0.100526765225204, 0.698419704324387), (0.100526765225204, 0.698419704324387, 0.100526765225204), (0.0568813795204234, 0.314372873493192, 0.314372873493192), (0.314372873493192, 0.314372873493192, 0.314372873493192), (0.314372873493192, 0.314372873493192, 0.0568813795204234), (0.314372873493192, 0.0568813795204234, 0.314372873493192)
    
    // Values of basis functions at quadrature points.
    static const double FE0[14][4] = \
    {{0.0, 0.0, 0.5, 0.5},
    {0.0, 0.5, 0.0, 0.5},
    {0.0, 0.5, 0.5, 0.0},
    {0.5, 0.5, 0.0, 0.0},
    {0.5, 0.0, 0.5, 0.0},
    {0.5, 0.0, 0.0, 0.5},
    {0.100526765225205, 0.698419704324386, 0.100526765225205, 0.100526765225205},
    {0.698419704324387, 0.100526765225204, 0.100526765225205, 0.100526765225205},
    {0.100526765225205, 0.100526765225204, 0.100526765225205, 0.698419704324386},
    {0.100526765225205, 0.100526765225204, 0.698419704324386, 0.100526765225205},
    {0.314372873493192, 0.0568813795204234, 0.314372873493192, 0.314372873493192},
    {0.0568813795204235, 0.314372873493192, 0.314372873493192, 0.314372873493192},
    {0.314372873493192, 0.314372873493192, 0.314372873493192, 0.0568813795204234},
    {0.314372873493192, 0.314372873493192, 0.0568813795204235, 0.314372873493192}};
    
    // Array of non-zero columns
    static const unsigned int nzc11[4] = {8, 9, 10, 11};
    
    static const double FE0_D001[14][2] = \
    {{-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc4[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc5[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc6[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc8[2] = {4, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc9[2] = {4, 6};
    
    // Array of non-zero columns
    static const unsigned int nzc10[2] = {4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc12[2] = {8, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc13[2] = {8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc14[2] = {8, 9};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 12; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 244.
    double G[40];
    G[0] =  - det*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]);
    G[1] =  - det*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]);
    G[2] =  - det*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]);
    G[3] = det*w[7][0]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]);
    G[4] = det*w[7][0]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]);
    G[5] = det*w[7][0]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]);
    G[6] = det*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]);
    G[7] = det*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]);
    G[8] = det*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]);
    G[9] =  - det*w[7][0]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]);
    G[10] =  - det*w[7][0]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]);
    G[11] =  - det*w[7][0]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]);
    G[12] = det*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8]);
    G[13] = det*(K[6]*K[6] + K[7]*K[7] + K[8]*K[8]);
    G[14] =  - det*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8]);
    G[15] =  - det*(K[6]*K[6] + K[7]*K[7] + K[8]*K[8]);
    G[16] = det*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]);
    G[17] =  - det*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]);
    G[18] = det*w[5][0]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]);
    G[19] = det*w[5][0]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8]);
    G[20] = det*w[5][0]*(K[6]*K[6] + K[7]*K[7] + K[8]*K[8]);
    G[21] =  - det*w[5][0]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]);
    G[22] =  - det*w[5][0]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8]);
    G[23] =  - det*w[5][0]*(K[6]*K[6] + K[7]*K[7] + K[8]*K[8]);
    G[24] = det*w[5][0]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]);
    G[25] = det*w[5][0]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]);
    G[26] =  - det*w[5][0]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]);
    G[27] =  - det*w[5][0]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]);
    G[28] = det*w[5][0]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]);
    G[29] =  - det*w[5][0]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]);
    G[30] = det*w[7][0]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8]);
    G[31] = det*w[7][0]*(K[6]*K[6] + K[7]*K[7] + K[8]*K[8]);
    G[32] =  - det*w[7][0]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8]);
    G[33] =  - det*w[7][0]*(K[6]*K[6] + K[7]*K[7] + K[8]*K[8]);
    G[34] = det*w[7][0]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]);
    G[35] =  - det*w[7][0]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]);
    G[36] =  - det*w[5][0];
    G[37] =  - det*w[7][0];
    G[38] = det*w[5][0];
    G[39] = det*w[7][0];
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 5558
    for (unsigned int ip = 0; ip < 14; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      double F10 = 0.0;
      double F11 = 0.0;
      double F12 = 0.0;
      double F13 = 0.0;
      double F14 = 0.0;
      double F15 = 0.0;
      double F16 = 0.0;
      double F17 = 0.0;
      double F18 = 0.0;
      double F19 = 0.0;
      double F20 = 0.0;
      double F21 = 0.0;
      double F22 = 0.0;
      double F23 = 0.0;
      double F24 = 0.0;
      
      // Total number of operations to compute function values = 72
      for (unsigned int r = 0; r < 2; r++)
      {
        F5 += FE0_D001[ip][r]*w[2][nzc2[r]];
        F6 += FE0_D001[ip][r]*w[2][nzc1[r]];
        F7 += FE0_D001[ip][r]*w[2][nzc0[r]];
        F8 += FE0_D001[ip][r]*w[0][nzc2[r]];
        F9 += FE0_D001[ip][r]*w[0][nzc1[r]];
        F10 += FE0_D001[ip][r]*w[0][nzc0[r]];
        F12 += FE0_D001[ip][r]*w[1][nzc2[r]];
        F13 += FE0_D001[ip][r]*w[1][nzc1[r]];
        F14 += FE0_D001[ip][r]*w[1][nzc0[r]];
        F16 += FE0_D001[ip][r]*w[10][nzc2[r]];
        F17 += FE0_D001[ip][r]*w[10][nzc1[r]];
        F18 += FE0_D001[ip][r]*w[10][nzc0[r]];
        F19 += FE0_D001[ip][r]*w[8][nzc2[r]];
        F20 += FE0_D001[ip][r]*w[8][nzc1[r]];
        F21 += FE0_D001[ip][r]*w[8][nzc0[r]];
        F22 += FE0_D001[ip][r]*w[9][nzc2[r]];
        F23 += FE0_D001[ip][r]*w[9][nzc1[r]];
        F24 += FE0_D001[ip][r]*w[9][nzc0[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 56
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0[ip][r]*w[8][r];
        F1 += FE0[ip][r]*w[9][r];
        F2 += FE0[ip][r]*w[0][r];
        F3 += FE0[ip][r]*w[1][r];
        F4 += FE0[ip][r]*w[4][r];
        F11 += FE0[ip][r]*w[6][r];
        F15 += FE0[ip][r]*w[3][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 225
      double I[10];
      // Number of operations: 29
      I[0] = F11*W14[ip]*(std::exp(F1)*(F16*G[3] + F17*G[4] + F18*G[5] + F22*G[6] + F23*G[7] + F24*G[8]) + std::exp(F3)*(F12*G[0] + F13*G[1] + F14*G[2] + F5*G[9] + F6*G[10] + F7*G[11]));
      
      // Number of operations: 13
      I[1] = F15*W14[ip]*(F16*G[8] + F17*G[12] + F18*G[13] + F5*G[2] + F6*G[14] + F7*G[15]);
      
      // Number of operations: 13
      I[2] = F15*W14[ip]*(F16*G[7] + F17*G[16] + F18*G[12] + F5*G[1] + F6*G[17] + F7*G[14]);
      
      // Number of operations: 13
      I[3] = F15*W14[ip]*(F16*G[6] + F17*G[7] + F18*G[8] + F5*G[0] + F6*G[1] + F7*G[2]);
      
      // Number of operations: 29
      I[4] = F4*W14[ip]*(std::exp(F0)*(F16*G[18] + F17*G[19] + F18*G[20] + F19*G[8] + F20*G[12] + F21*G[13]) + std::exp(F2)*(F10*G[15] + F5*G[21] + F6*G[22] + F7*G[23] + F8*G[2] + F9*G[14]));
      
      // Number of operations: 29
      I[5] = F4*W14[ip]*(std::exp(F0)*(F16*G[24] + F17*G[25] + F18*G[19] + F19*G[7] + F20*G[16] + F21*G[12]) + std::exp(F2)*(F10*G[14] + F5*G[26] + F6*G[27] + F7*G[22] + F8*G[1] + F9*G[17]));
      
      // Number of operations: 29
      I[6] = F4*W14[ip]*(std::exp(F0)*(F16*G[28] + F17*G[24] + F18*G[18] + F19*G[6] + F20*G[7] + F21*G[8]) + std::exp(F2)*(F10*G[2] + F5*G[29] + F6*G[26] + F7*G[21] + F8*G[0] + F9*G[1]));
      
      // Number of operations: 29
      I[7] = F11*W14[ip]*(std::exp(F1)*(F16*G[5] + F17*G[30] + F18*G[31] + F22*G[8] + F23*G[12] + F24*G[13]) + std::exp(F3)*(F12*G[2] + F13*G[14] + F14*G[15] + F5*G[11] + F6*G[32] + F7*G[33]));
      
      // Number of operations: 29
      I[8] = F11*W14[ip]*(std::exp(F1)*(F16*G[4] + F17*G[34] + F18*G[30] + F22*G[7] + F23*G[16] + F24*G[12]) + std::exp(F3)*(F12*G[1] + F13*G[17] + F14*G[14] + F5*G[10] + F6*G[35] + F7*G[32]));
      
      // Number of operations: 12
      I[9] = W14[ip]*(G[36]*std::exp(F0) + G[37]*std::exp(F1) + G[38]*std::exp(F2) + G[39]*std::exp(F3));
      
      
      // Number of operations for primary indices: 36
      for (unsigned int j = 0; j < 2; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc10[j]] += FE0_D001[ip][j]*I[0];
        // Number of operations to compute entry: 2
        A[nzc12[j]] += FE0_D001[ip][j]*I[1];
        // Number of operations to compute entry: 2
        A[nzc13[j]] += FE0_D001[ip][j]*I[2];
        // Number of operations to compute entry: 2
        A[nzc14[j]] += FE0_D001[ip][j]*I[3];
        // Number of operations to compute entry: 2
        A[nzc4[j]] += FE0_D001[ip][j]*I[4];
        // Number of operations to compute entry: 2
        A[nzc5[j]] += FE0_D001[ip][j]*I[5];
        // Number of operations to compute entry: 2
        A[nzc6[j]] += FE0_D001[ip][j]*I[6];
        // Number of operations to compute entry: 2
        A[nzc8[j]] += FE0_D001[ip][j]*I[7];
        // Number of operations to compute entry: 2
        A[nzc9[j]] += FE0_D001[ip][j]*I[8];
      } // end loop over 'j'
      
      // Number of operations for primary indices: 8
      for (unsigned int j = 0; j < 4; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc11[j]] += FE0[ip][j]*I[9];
      } // end loop over 'j'
    } // end loop over 'ip'
  }

};


class pnp_and_source_cell_integral_2_otherwise: public ufc::cell_integral
{
public:

  pnp_and_source_cell_integral_2_otherwise() : ufc::cell_integral()
  {
    
  }

  ~pnp_and_source_cell_integral_2_otherwise() override
  {
    
  }

  const std::vector<bool> & enabled_coefficients() const final override
  {
    static const std::vector<bool> enabled({true, true, true, true, true, true, true, true, true, true, true});
    return enabled;
  }

  void tabulate_tensor(double * A,
                       const double * const * w,
                       const double * coordinate_dofs,
                       int cell_orientation) const final override
  {
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W125[125] = {0.000937439821766984, 0.00144688123847004, 0.00102268701578053, 0.000367520038007324, 4.71653365059364e-05, 0.00161927658526931, 0.00249925473264391, 0.00176652740822439, 0.000634831781565252, 8.1470536312884e-05, 0.00141792453255091, 0.00218848010941898, 0.00154686516950305, 0.000555892406098532, 7.13399262170554e-05, 0.000715891501943862, 0.00110493490770459, 0.000780991938624509, 0.000280662785913662, 3.60185932012982e-05, 0.000152536470498617, 0.000235430746830112, 0.000166407554052789, 5.9801395389292e-05, 7.67455552179798e-06, 0.00189377231486028, 0.00292292216383614, 0.00206598473020027, 0.000742446882427904, 9.52812185081393e-05, 0.00327118722298822, 0.00504887813656484, 0.00356865648488397, 0.00128245763045954, 0.000164582987156811, 0.00286442517370846, 0.00442106570107946, 0.00312490504969682, 0.00112298797668544, 0.000144117599953649, 0.00144621070637857, 0.0022321380949974, 0.00157772357985427, 0.000566981902660165, 7.27630862707133e-05, 0.000308147081155878, 0.000475606241660779, 0.000336168798819301, 0.000120807996789371, 1.55037800172006e-05, 0.00225090157446143, 0.00347412941301361, 0.00245558995953753, 0.00088245817276838, 0.000113249435042247, 0.00388807060532276, 0.00600100004508522, 0.00424163688396193, 0.00152430462570915, 0.00019562019257218, 0.0034046010087031, 0.0052547941847441, 0.00371420241029555, 0.00133476204345558, 0.000171295424533231, 0.00171893840164765, 0.00265307667295562, 0.00187525208922536, 0.000673903851785402, 8.64848134932762e-05, 0.000366257730507922, 0.000565296487744311, 0.000399563808494581, 0.000143590075769372, 1.8427496577589e-05, 0.00189377231486028, 0.00292292216383614, 0.00206598473020027, 0.000742446882427904, 9.52812185081393e-05, 0.00327118722298822, 0.00504887813656484, 0.00356865648488397, 0.00128245763045954, 0.000164582987156811, 0.00286442517370846, 0.00442106570107946, 0.00312490504969682, 0.00112298797668544, 0.000144117599953649, 0.00144621070637857, 0.0022321380949974, 0.00157772357985427, 0.000566981902660165, 7.27630862707133e-05, 0.000308147081155878, 0.000475606241660779, 0.000336168798819301, 0.000120807996789371, 1.55037800172006e-05, 0.000937439821766984, 0.00144688123847004, 0.00102268701578053, 0.000367520038007324, 4.71653365059364e-05, 0.00161927658526931, 0.00249925473264391, 0.00176652740822439, 0.000634831781565252, 8.14705363128841e-05, 0.00141792453255091, 0.00218848010941898, 0.00154686516950305, 0.000555892406098532, 7.13399262170555e-05, 0.000715891501943862, 0.00110493490770459, 0.000780991938624509, 0.000280662785913662, 3.60185932012982e-05, 0.000152536470498617, 0.000235430746830112, 0.000166407554052789, 5.9801395389292e-05, 7.67455552179798e-06};
    // Quadrature points on the UFC reference element: (0.0434850684329929, 0.0384332743963333, 0.034578939918215), (0.0372285899889251, 0.0329036302803046, 0.173480320771696), (0.0274810994988124, 0.0242885357160768, 0.389886387065519), (0.0164705687743685, 0.0145571321830714, 0.634333472630887), (0.0067089045501621, 0.00592951049099777, 0.851054212947016), (0.0363203493206216, 0.191166323793956, 0.034578939918215), (0.0310947054204484, 0.163661986623795, 0.173480320771696), (0.0229532381913956, 0.120810681788372, 0.389886387065519), (0.0137568327003139, 0.0724068788863314, 0.634333472630887), (0.00560352704046152, 0.0294932643722359, 0.851054212947016), (0.025452983470971, 0.42283010559815, 0.034578939918215), (0.0217908978824722, 0.361994799675747, 0.173480320771696), (0.0160854287808059, 0.267214393854326, 0.389886387065519), (0.00964066816216436, 0.160152727938308, 0.634333472630887), (0.00392690279162666, 0.0652345028216781, 0.851054212947016), (0.0137918067694829, 0.671415856030076, 0.034578939918215), (0.0118074902013492, 0.574814908126993, 0.173480320771696), (0.00871595763232119, 0.42431222048264, 0.389886387065519), (0.00522383682733774, 0.254308005746508, 0.634333472630887), (0.00212780888992548, 0.103586473561889, 0.851054212947016), (0.00446245462992895, 0.870293213094632, 0.034578939918215), (0.00382041237943087, 0.745078491721125, 0.173480320771696), (0.00282012111543484, 0.54999601573695, 0.389886387065519), (0.00169021617151183, 0.329635544721039, 0.634333472630887), (0.000688470393412244, 0.134269401146344, 0.851054212947016), (0.213916656125506, 0.0384332743963333, 0.034578939918215), (0.183139081291086, 0.0329036302803046, 0.173480320771696), (0.135188126023001, 0.0242885357160768, 0.389886387065519), (0.0810238806942951, 0.0145571321830714, 0.634333472630887), (0.0330032003938849, 0.00592951049099777, 0.851054212947016), (0.178671161296432, 0.191166323793956, 0.034578939918215), (0.152964584084757, 0.163661986623795, 0.173480320771696), (0.112914159689587, 0.120810681788372, 0.389886387065519), (0.0676741639412116, 0.0724068788863314, 0.634333472630887), (0.027565502601231, 0.0294932643722359, 0.851054212947016), (0.125211188776624, 0.42283010559815, 0.034578939918215), (0.107196244066483, 0.361994799675747, 0.173480320771696), (0.0791292565731431, 0.267214393854326, 0.389886387065519), (0.0474254628170509, 0.160152727938308, 0.634333472630887), (0.0193176633816068, 0.0652345028216781, 0.851054212947016), (0.0678462123292524, 0.671415856030076, 0.034578939918215), (0.0580847383280397, 0.574814908126993, 0.173480320771696), (0.0428765224208113, 0.42431222048264, 0.389886387065519), (0.0256976876550462, 0.254308005746508, 0.634333472630887), (0.0104673576243388, 0.103586473561889, 0.851054212947016), (0.0219522104240708, 0.870293213094632, 0.034578939918215), (0.0187938037280005, 0.745078491721125, 0.173480320771696), (0.0138730580546826, 0.54999601573695, 0.389886387065519), (0.00831470213956798, 0.329635544721039, 0.634333472630887), (0.00338680125632329, 0.134269401146344, 0.851054212947016), (0.463493892842726, 0.0384332743963333, 0.034578939918215), (0.396808024474, 0.0329036302803046, 0.173480320771696), (0.292912538609202, 0.0242885357160768, 0.389886387065519), (0.175554697593021, 0.0145571321830714, 0.634333472630887), (0.0715081382809929, 0.00592951049099777, 0.851054212947016), (0.387127368143914, 0.191166323793956, 0.034578939918215), (0.331428846302255, 0.163661986623795, 0.173480320771696), (0.244651465573054, 0.120810681788372, 0.389886387065519), (0.146629824241391, 0.0724068788863314, 0.634333472630887), (0.0597262613403738, 0.0294932643722359, 0.851054212947016), (0.271295477241817, 0.42283010559815, 0.034578939918215), (0.232262439776279, 0.361994799675747, 0.173480320771696), (0.171449609540077, 0.267214393854326, 0.389886387065519), (0.102756899715403, 0.160152727938308, 0.634333472630887), (0.0418556421156527, 0.0652345028216781, 0.851054212947016), (0.147002602025855, 0.671415856030076, 0.034578939918215), (0.125852385550656, 0.574814908126993, 0.173480320771696), (0.0929006962259202, 0.42431222048264, 0.389886387065519), (0.0556792608113027, 0.254308005746508, 0.634333472630887), (0.0226796567455474, 0.103586473561889, 0.851054212947016), (0.0475639234935763, 0.870293213094632, 0.034578939918215), (0.0407205937535897, 0.745078491721125, 0.173480320771696), (0.0300587985987655, 0.54999601573695, 0.389886387065519), (0.0180154913240372, 0.329635544721039, 0.634333472630887), (0.00733819295331972, 0.134269401146344, 0.851054212947016), (0.713071129559946, 0.0384332743963333, 0.034578939918215), (0.610476967656914, 0.0329036302803046, 0.173480320771696), (0.450636951195403, 0.0242885357160768, 0.389886387065519), (0.270085514491747, 0.0145571321830714, 0.634333472630887), (0.110013076168101, 0.00592951049099777, 0.851054212947016), (0.595583574991397, 0.191166323793956, 0.034578939918215), (0.509893108519752, 0.163661986623795, 0.173480320771696), (0.376388771456521, 0.120810681788372, 0.389886387065519), (0.22558548454157, 0.0724068788863314, 0.634333472630887), (0.0918870200795167, 0.0294932643722359, 0.851054212947016), (0.417379765707011, 0.42283010559815, 0.034578939918215), (0.357328635486074, 0.361994799675747, 0.173480320771696), (0.263769962507011, 0.267214393854326, 0.389886387065519), (0.158088336613754, 0.160152727938308, 0.634333472630887), (0.0643936208496987, 0.0652345028216781, 0.851054212947016), (0.226158991722457, 0.671415856030076, 0.034578939918215), (0.193620032773272, 0.574814908126993, 0.173480320771696), (0.142924870031029, 0.42431222048264, 0.389886387065519), (0.0856608339675592, 0.254308005746508, 0.634333472630887), (0.0348919558667561, 0.103586473561889, 0.851054212947016), (0.0731756365630818, 0.870293213094632, 0.034578939918215), (0.062647383779179, 0.745078491721125, 0.173480320771696), (0.0462445391428484, 0.54999601573695, 0.389886387065519), (0.0277162805085065, 0.329635544721039, 0.634333472630887), (0.0112895846503162, 0.134269401146344, 0.851054212947016), (0.883502717252459, 0.0384332743963333, 0.034578939918215), (0.756387458959075, 0.0329036302803046, 0.173480320771696), (0.558343977719591, 0.0242885357160768, 0.389886387065519), (0.334638826411673, 0.0145571321830714, 0.634333472630887), (0.136307372011824, 0.00592951049099777, 0.851054212947016), (0.737934386967207, 0.191166323793956, 0.034578939918215), (0.631762987184061, 0.163661986623795, 0.173480320771696), (0.466349692954713, 0.120810681788372, 0.389886387065519), (0.279502815782468, 0.0724068788863314, 0.634333472630887), (0.113848995640286, 0.0294932643722359, 0.851054212947016), (0.517137971012664, 0.42283010559815, 0.034578939918215), (0.442733981670085, 0.361994799675747, 0.173480320771696), (0.326813790299348, 0.267214393854326, 0.389886387065519), (0.195873131268641, 0.160152727938308, 0.634333472630887), (0.0797843814396788, 0.0652345028216781, 0.851054212947016), (0.280213397282226, 0.671415856030076, 0.034578939918215), (0.239897280899962, 0.574814908126993, 0.173480320771696), (0.177085434819519, 0.42431222048264, 0.389886387065519), (0.106134684795268, 0.254308005746508, 0.634333472630887), (0.0432315046011695, 0.103586473561889, 0.851054212947016), (0.0906653923572237, 0.870293213094632, 0.034578939918215), (0.0776207751277486, 0.745078491721125, 0.173480320771696), (0.0572974760820962, 0.54999601573695, 0.389886387065519), (0.0343407664765626, 0.329635544721039, 0.634333472630887), (0.0139879155132272, 0.134269401146344, 0.851054212947016)
    
    // Values of basis functions at quadrature points.
    static const double FE0[125][4] = \
    {{0.883502717252459, 0.0434850684329927, 0.0384332743963333, 0.034578939918215},
    {0.756387458959075, 0.037228589988925, 0.0329036302803046, 0.173480320771696},
    {0.558343977719591, 0.0274810994988122, 0.0242885357160769, 0.389886387065519},
    {0.334638826411673, 0.0164705687743684, 0.0145571321830714, 0.634333472630887},
    {0.136307372011824, 0.00670890455016213, 0.00592951049099774, 0.851054212947016},
    {0.737934386967207, 0.0363203493206215, 0.191166323793956, 0.034578939918215},
    {0.631762987184061, 0.0310947054204485, 0.163661986623795, 0.173480320771696},
    {0.466349692954713, 0.0229532381913955, 0.120810681788372, 0.389886387065519},
    {0.279502815782468, 0.0137568327003139, 0.0724068788863314, 0.634333472630887},
    {0.113848995640286, 0.00560352704046155, 0.0294932643722359, 0.851054212947016},
    {0.517137971012664, 0.0254529834709709, 0.42283010559815, 0.034578939918215},
    {0.442733981670085, 0.0217908978824722, 0.361994799675747, 0.173480320771696},
    {0.326813790299348, 0.0160854287808059, 0.267214393854326, 0.389886387065519},
    {0.195873131268641, 0.00964066816216433, 0.160152727938308, 0.634333472630887},
    {0.0797843814396789, 0.00392690279162669, 0.0652345028216781, 0.851054212947016},
    {0.280213397282226, 0.0137918067694829, 0.671415856030076, 0.034578939918215},
    {0.239897280899962, 0.0118074902013492, 0.574814908126993, 0.173480320771696},
    {0.177085434819519, 0.00871595763232122, 0.42431222048264, 0.389886387065519},
    {0.106134684795268, 0.00522383682733774, 0.254308005746508, 0.634333472630887},
    {0.0432315046011695, 0.00212780888992553, 0.103586473561889, 0.851054212947016},
    {0.0906653923572237, 0.00446245462992891, 0.870293213094632, 0.034578939918215},
    {0.0776207751277486, 0.00382041237943086, 0.745078491721125, 0.173480320771696},
    {0.0572974760820963, 0.00282012111543484, 0.54999601573695, 0.389886387065519},
    {0.0343407664765628, 0.00169021617151183, 0.329635544721039, 0.634333472630887},
    {0.0139879155132273, 0.000688470393412272, 0.134269401146344, 0.851054212947016},
    {0.713071129559946, 0.213916656125506, 0.0384332743963333, 0.034578939918215},
    {0.610476967656914, 0.183139081291086, 0.0329036302803046, 0.173480320771696},
    {0.450636951195403, 0.135188126023001, 0.0242885357160769, 0.389886387065519},
    {0.270085514491747, 0.0810238806942951, 0.0145571321830714, 0.634333472630887},
    {0.110013076168101, 0.0330032003938849, 0.00592951049099774, 0.851054212947016},
    {0.595583574991397, 0.178671161296432, 0.191166323793956, 0.034578939918215},
    {0.509893108519752, 0.152964584084757, 0.163661986623795, 0.173480320771696},
    {0.376388771456521, 0.112914159689587, 0.120810681788372, 0.389886387065519},
    {0.22558548454157, 0.0676741639412116, 0.0724068788863314, 0.634333472630887},
    {0.0918870200795167, 0.0275655026012311, 0.0294932643722359, 0.851054212947016},
    {0.417379765707011, 0.125211188776624, 0.42283010559815, 0.034578939918215},
    {0.357328635486074, 0.107196244066483, 0.361994799675747, 0.173480320771696},
    {0.263769962507011, 0.0791292565731431, 0.267214393854326, 0.389886387065519},
    {0.158088336613754, 0.0474254628170509, 0.160152727938308, 0.634333472630887},
    {0.0643936208496987, 0.0193176633816069, 0.0652345028216781, 0.851054212947016},
    {0.226158991722457, 0.0678462123292524, 0.671415856030076, 0.034578939918215},
    {0.193620032773272, 0.0580847383280397, 0.574814908126993, 0.173480320771696},
    {0.142924870031029, 0.0428765224208113, 0.42431222048264, 0.389886387065519},
    {0.0856608339675594, 0.0256976876550462, 0.254308005746508, 0.634333472630887},
    {0.0348919558667562, 0.0104673576243389, 0.103586473561889, 0.851054212947016},
    {0.0731756365630819, 0.0219522104240708, 0.870293213094632, 0.034578939918215},
    {0.062647383779179, 0.0187938037280005, 0.745078491721125, 0.173480320771696},
    {0.0462445391428486, 0.0138730580546826, 0.54999601573695, 0.389886387065519},
    {0.0277162805085066, 0.00831470213956798, 0.329635544721039, 0.634333472630887},
    {0.0112895846503162, 0.00338680125632332, 0.134269401146344, 0.851054212947016},
    {0.463493892842726, 0.463493892842726, 0.0384332743963333, 0.034578939918215},
    {0.396808024474, 0.396808024474, 0.0329036302803046, 0.173480320771696},
    {0.292912538609202, 0.292912538609202, 0.0242885357160769, 0.389886387065519},
    {0.175554697593021, 0.175554697593021, 0.0145571321830714, 0.634333472630887},
    {0.071508138280993, 0.0715081382809929, 0.00592951049099774, 0.851054212947016},
    {0.387127368143914, 0.387127368143914, 0.191166323793956, 0.034578939918215},
    {0.331428846302255, 0.331428846302255, 0.163661986623795, 0.173480320771696},
    {0.244651465573054, 0.244651465573054, 0.120810681788372, 0.389886387065519},
    {0.146629824241391, 0.146629824241391, 0.0724068788863314, 0.634333472630887},
    {0.0597262613403739, 0.0597262613403739, 0.0294932643722359, 0.851054212947016},
    {0.271295477241817, 0.271295477241817, 0.42283010559815, 0.034578939918215},
    {0.232262439776279, 0.232262439776279, 0.361994799675747, 0.173480320771696},
    {0.171449609540077, 0.171449609540077, 0.267214393854326, 0.389886387065519},
    {0.102756899715403, 0.102756899715403, 0.160152727938308, 0.634333472630887},
    {0.0418556421156528, 0.0418556421156527, 0.0652345028216781, 0.851054212947016},
    {0.147002602025855, 0.147002602025855, 0.671415856030075, 0.034578939918215},
    {0.125852385550656, 0.125852385550656, 0.574814908126993, 0.173480320771696},
    {0.0929006962259204, 0.0929006962259202, 0.42431222048264, 0.389886387065519},
    {0.0556792608113028, 0.0556792608113027, 0.254308005746508, 0.634333472630887},
    {0.0226796567455476, 0.0226796567455475, 0.103586473561889, 0.851054212947016},
    {0.0475639234935764, 0.0475639234935763, 0.870293213094632, 0.034578939918215},
    {0.0407205937535898, 0.0407205937535897, 0.745078491721125, 0.173480320771696},
    {0.0300587985987656, 0.0300587985987655, 0.54999601573695, 0.389886387065519},
    {0.0180154913240373, 0.0180154913240372, 0.329635544721039, 0.634333472630887},
    {0.00733819295331981, 0.00733819295331975, 0.134269401146344, 0.851054212947016},
    {0.213916656125506, 0.713071129559945, 0.0384332743963333, 0.034578939918215},
    {0.183139081291086, 0.610476967656913, 0.0329036302803046, 0.173480320771696},
    {0.135188126023001, 0.450636951195403, 0.0242885357160769, 0.389886387065519},
    {0.0810238806942952, 0.270085514491747, 0.0145571321830714, 0.634333472630887},
    {0.0330032003938849, 0.110013076168101, 0.00592951049099774, 0.851054212947016},
    {0.178671161296432, 0.595583574991396, 0.191166323793956, 0.034578939918215},
    {0.152964584084757, 0.509893108519752, 0.163661986623795, 0.173480320771696},
    {0.112914159689588, 0.376388771456521, 0.120810681788372, 0.389886387065519},
    {0.0676741639412117, 0.22558548454157, 0.0724068788863314, 0.634333472630887},
    {0.0275655026012311, 0.0918870200795167, 0.0294932643722359, 0.851054212947016},
    {0.125211188776624, 0.417379765707011, 0.42283010559815, 0.034578939918215},
    {0.107196244066483, 0.357328635486074, 0.361994799675747, 0.173480320771696},
    {0.0791292565731432, 0.263769962507011, 0.267214393854326, 0.389886387065519},
    {0.047425462817051, 0.158088336613754, 0.160152727938308, 0.634333472630887},
    {0.0193176633816069, 0.0643936208496988, 0.0652345028216781, 0.851054212947016},
    {0.0678462123292526, 0.226158991722457, 0.671415856030076, 0.034578939918215},
    {0.0580847383280398, 0.193620032773272, 0.574814908126993, 0.173480320771696},
    {0.0428765224208115, 0.142924870031029, 0.42431222048264, 0.389886387065519},
    {0.0256976876550463, 0.0856608339675592, 0.254308005746508, 0.634333472630887},
    {0.0104673576243389, 0.0348919558667562, 0.103586473561889, 0.851054212947016},
    {0.0219522104240709, 0.0731756365630818, 0.870293213094632, 0.034578939918215},
    {0.0187938037280005, 0.062647383779179, 0.745078491721125, 0.173480320771696},
    {0.0138730580546828, 0.0462445391428484, 0.549996015736949, 0.389886387065519},
    {0.00831470213956809, 0.0277162805085065, 0.329635544721039, 0.634333472630887},
    {0.00338680125632332, 0.0112895846503162, 0.134269401146344, 0.851054212947016},
    {0.0434850684329929, 0.883502717252459, 0.0384332743963333, 0.034578939918215},
    {0.0372285899889251, 0.756387458959075, 0.0329036302803046, 0.173480320771696},
    {0.0274810994988124, 0.558343977719591, 0.0242885357160769, 0.389886387065519},
    {0.0164705687743686, 0.334638826411673, 0.0145571321830714, 0.634333472630887},
    {0.00670890455016213, 0.136307372011824, 0.00592951049099774, 0.851054212947016},
    {0.0363203493206218, 0.737934386967207, 0.191166323793956, 0.034578939918215},
    {0.0310947054204485, 0.631762987184061, 0.163661986623795, 0.173480320771696},
    {0.0229532381913957, 0.466349692954713, 0.120810681788372, 0.389886387065519},
    {0.013756832700314, 0.279502815782468, 0.0724068788863314, 0.634333472630887},
    {0.00560352704046149, 0.113848995640286, 0.0294932643722359, 0.851054212947016},
    {0.0254529834709711, 0.517137971012664, 0.42283010559815, 0.034578939918215},
    {0.0217908978824723, 0.442733981670085, 0.361994799675747, 0.173480320771696},
    {0.0160854287808061, 0.326813790299348, 0.267214393854326, 0.389886387065519},
    {0.00964066816216444, 0.195873131268641, 0.160152727938308, 0.634333472630887},
    {0.00392690279162675, 0.0797843814396788, 0.0652345028216781, 0.851054212947016},
    {0.0137918067694832, 0.280213397282226, 0.671415856030076, 0.034578939918215},
    {0.0118074902013494, 0.239897280899962, 0.574814908126993, 0.173480320771696},
    {0.00871595763232141, 0.177085434819519, 0.42431222048264, 0.389886387065519},
    {0.00522383682733785, 0.106134684795268, 0.254308005746508, 0.634333472630887},
    {0.00212780888992553, 0.0432315046011696, 0.103586473561889, 0.851054212947016},
    {0.004462454629929, 0.0906653923572237, 0.870293213094632, 0.034578939918215},
    {0.00382041237943098, 0.0776207751277486, 0.745078491721125, 0.173480320771696},
    {0.00282012111543502, 0.0572974760820962, 0.54999601573695, 0.389886387065519},
    {0.00169021617151194, 0.0343407664765626, 0.329635544721039, 0.634333472630887},
    {0.000688470393412327, 0.0139879155132273, 0.134269401146344, 0.851054212947016}};
    
    static const double FE0_D001[125][2] = \
    {{-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0},
    {-1.0, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 1};
    
    // Reset values in the element tensor.
    A[0] = 0.0;
    // Number of operations to compute geometry constants: 14050.
    double G[477];
    G[0] = det*w[5][0]*w[5][0]*(K[0]*K[0]*K[0]*K[0] + K[1]*K[1]*(2.0*K[0]*K[0] + K[1]*K[1]) + K[2]*K[2]*(2.0*(K[0]*K[0] + K[1]*K[1]) + K[2]*K[2]));
    G[1] = 2.0*det*w[5][0]*w[5][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[2] = 2.0*det*w[5][0]*w[5][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[3] = det*w[5][0]*w[5][0]*(2.0*K[0]*K[0]*K[0]*K[0] + K[1]*K[1]*(2.0*K[1]*K[1] + 4.0*K[0]*K[0]) + K[2]*K[2]*(2.0*K[2]*K[2] + 4.0*(K[0]*K[0] + K[1]*K[1])));
    G[4] = det*w[5][0]*w[5][0]*(K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(2.0*K[0]*K[3] + K[1]*K[4]) + K[2]*K[5]*(2.0*(K[0]*K[3] + K[1]*K[4]) + K[2]*K[5]));
    G[5] = 2.0*det*w[5][0]*w[5][0]*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[6] = det*w[5][0]*w[5][0]*(2.0*K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(2.0*K[1]*K[4] + 4.0*K[0]*K[3]) + K[2]*K[5]*(2.0*K[2]*K[5] + 4.0*(K[0]*K[3] + K[1]*K[4])));
    G[7] = det*w[5][0]*w[5][0]*(K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(2.0*K[0]*K[6] + K[1]*K[7]) + K[2]*K[8]*(2.0*(K[0]*K[6] + K[1]*K[7]) + K[2]*K[8]));
    G[8] = det*w[5][0]*w[5][0]*(2.0*K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(2.0*K[1]*K[7] + 4.0*K[0]*K[6]) + K[2]*K[8]*(2.0*K[2]*K[8] + 4.0*(K[0]*K[6] + K[1]*K[7])));
    G[9] = det*w[7][0]*w[7][0]*(K[0]*K[0]*K[0]*K[0] + K[1]*K[1]*(2.0*K[0]*K[0] + K[1]*K[1]) + K[2]*K[2]*(2.0*(K[0]*K[0] + K[1]*K[1]) + K[2]*K[2]));
    G[10] = 2.0*det*w[7][0]*w[7][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[11] = 2.0*det*w[7][0]*w[7][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[12] = det*w[7][0]*w[7][0]*(2.0*K[0]*K[0]*K[0]*K[0] + K[1]*K[1]*(2.0*K[1]*K[1] + 4.0*K[0]*K[0]) + K[2]*K[2]*(2.0*K[2]*K[2] + 4.0*(K[0]*K[0] + K[1]*K[1])));
    G[13] = det*w[7][0]*w[7][0]*(K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(2.0*K[0]*K[3] + K[1]*K[4]) + K[2]*K[5]*(2.0*(K[0]*K[3] + K[1]*K[4]) + K[2]*K[5]));
    G[14] = 2.0*det*w[7][0]*w[7][0]*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[15] = det*w[7][0]*w[7][0]*(2.0*K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(2.0*K[1]*K[4] + 4.0*K[0]*K[3]) + K[2]*K[5]*(2.0*K[2]*K[5] + 4.0*(K[0]*K[3] + K[1]*K[4])));
    G[16] = det*w[7][0]*w[7][0]*(K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(2.0*K[0]*K[6] + K[1]*K[7]) + K[2]*K[8]*(2.0*(K[0]*K[6] + K[1]*K[7]) + K[2]*K[8]));
    G[17] = det*w[7][0]*w[7][0]*(2.0*K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(2.0*K[1]*K[7] + 4.0*K[0]*K[6]) + K[2]*K[8]*(2.0*K[2]*K[8] + 4.0*(K[0]*K[6] + K[1]*K[7])));
    G[18] = det*(K[0]*K[0]*K[0]*K[0] + K[1]*K[1]*(2.0*K[0]*K[0] + K[1]*K[1]) + K[2]*K[2]*(2.0*(K[0]*K[0] + K[1]*K[1]) + K[2]*K[2]));
    G[19] = 2.0*det*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[20] = 2.0*det*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[21] = det*(K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(2.0*K[0]*K[3] + K[1]*K[4]) + K[2]*K[5]*(2.0*(K[0]*K[3] + K[1]*K[4]) + K[2]*K[5]));
    G[22] = 2.0*det*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[23] = det*(K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(2.0*K[0]*K[6] + K[1]*K[7]) + K[2]*K[8]*(2.0*(K[0]*K[6] + K[1]*K[7]) + K[2]*K[8]));
    G[24] = det*w[5][0]*w[5][0]*(2.0*(K[3]*K[3]*(K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1])) + 4.0*(K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(K[0]*K[3] + K[1]*K[4]) + K[2]*K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[25] = det*w[5][0]*w[5][0]*(2.0*(K[0]*K[0]*(K[4]*K[7] + K[5]*K[8]) + K[1]*(K[0]*K[3]*K[7] + K[1]*K[5]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[2]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 4.0*(K[0]*K[0]*K[3]*K[6] + K[1]*K[1]*K[4]*K[7] + K[2]*K[2]*K[5]*K[8]));
    G[26] = 4.0*det*w[5][0]*w[5][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[27] = 2.0*det*w[5][0]*w[5][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[28] = det*w[5][0]*w[5][0]*(2.0*(K[3]*K[3]*(K[1]*K[7] + K[2]*K[8]) + K[4]*(K[0]*K[3]*K[7] + K[2]*K[4]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[5]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 4.0*(K[0]*K[3]*K[3]*K[6] + K[1]*K[4]*K[4]*K[7] + K[2]*K[5]*K[5]*K[8]));
    G[29] = 4.0*det*w[5][0]*w[5][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[30] = 2.0*det*w[5][0]*w[5][0]*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[31] = 4.0*det*w[5][0]*w[5][0]*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[32] = det*w[7][0]*w[7][0]*(2.0*(K[3]*K[3]*(K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1])) + 4.0*(K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(K[0]*K[3] + K[1]*K[4]) + K[2]*K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[33] = det*w[7][0]*w[7][0]*(2.0*(K[0]*K[0]*(K[4]*K[7] + K[5]*K[8]) + K[1]*(K[0]*K[3]*K[7] + K[1]*K[5]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[2]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 4.0*(K[0]*K[0]*K[3]*K[6] + K[1]*K[1]*K[4]*K[7] + K[2]*K[2]*K[5]*K[8]));
    G[34] = 4.0*det*w[7][0]*w[7][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[35] = 2.0*det*w[7][0]*w[7][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[36] = det*w[7][0]*w[7][0]*(2.0*(K[3]*K[3]*(K[1]*K[7] + K[2]*K[8]) + K[4]*(K[0]*K[3]*K[7] + K[2]*K[4]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[5]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 4.0*(K[0]*K[3]*K[3]*K[6] + K[1]*K[4]*K[4]*K[7] + K[2]*K[5]*K[5]*K[8]));
    G[37] = 4.0*det*w[7][0]*w[7][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[38] = 2.0*det*w[7][0]*w[7][0]*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[39] = 4.0*det*w[7][0]*w[7][0]*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[40] = det*(2.0*(K[3]*K[3]*(K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1])) + 4.0*(K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(K[0]*K[3] + K[1]*K[4]) + K[2]*K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[41] = det*(2.0*(K[0]*K[0]*(K[4]*K[7] + K[5]*K[8]) + K[1]*(K[0]*K[3]*K[7] + K[1]*K[5]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[2]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 4.0*(K[0]*K[0]*K[3]*K[6] + K[1]*K[1]*K[4]*K[7] + K[2]*K[2]*K[5]*K[8]));
    G[42] = 2.0*det*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[43] = det*(2.0*(K[3]*K[3]*(K[1]*K[7] + K[2]*K[8]) + K[4]*(K[0]*K[3]*K[7] + K[2]*K[4]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[5]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 4.0*(K[0]*K[3]*K[3]*K[6] + K[1]*K[4]*K[4]*K[7] + K[2]*K[5]*K[5]*K[8]));
    G[44] = 2.0*det*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[45] = det*w[5][0]*w[5][0]*(2.0*(K[6]*K[6]*(K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1])) + 4.0*(K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(K[0]*K[6] + K[1]*K[7]) + K[2]*K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[46] = 4.0*det*w[5][0]*w[5][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[47] = 2.0*det*w[5][0]*w[5][0]*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[48] = det*w[5][0]*w[5][0]*(2.0*(K[6]*K[6]*(K[1]*K[4] + K[2]*K[5]) + K[7]*(K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(K[0]*K[3] + K[2]*K[5])) + K[8]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 4.0*(K[0]*K[3]*K[6]*K[6] + K[1]*K[4]*K[7]*K[7] + K[2]*K[5]*K[8]*K[8]));
    G[49] = 4.0*det*w[5][0]*w[5][0]*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[50] = 2.0*det*w[5][0]*w[5][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[51] = 4.0*det*w[5][0]*w[5][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[52] = det*w[7][0]*w[7][0]*(2.0*(K[6]*K[6]*(K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1])) + 4.0*(K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(K[0]*K[6] + K[1]*K[7]) + K[2]*K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[53] = 4.0*det*w[7][0]*w[7][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[54] = 2.0*det*w[7][0]*w[7][0]*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[55] = det*w[7][0]*w[7][0]*(2.0*(K[6]*K[6]*(K[1]*K[4] + K[2]*K[5]) + K[7]*(K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(K[0]*K[3] + K[2]*K[5])) + K[8]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 4.0*(K[0]*K[3]*K[6]*K[6] + K[1]*K[4]*K[7]*K[7] + K[2]*K[5]*K[8]*K[8]));
    G[56] = 4.0*det*w[7][0]*w[7][0]*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[57] = 2.0*det*w[7][0]*w[7][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[58] = 4.0*det*w[7][0]*w[7][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[59] = det*(2.0*(K[6]*K[6]*(K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1])) + 4.0*(K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(K[0]*K[6] + K[1]*K[7]) + K[2]*K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[60] = 2.0*det*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[61] = det*(2.0*(K[6]*K[6]*(K[1]*K[4] + K[2]*K[5]) + K[7]*(K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(K[0]*K[3] + K[2]*K[5])) + K[8]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 4.0*(K[0]*K[3]*K[6]*K[6] + K[1]*K[4]*K[7]*K[7] + K[2]*K[5]*K[8]*K[8]));
    G[62] = 2.0*det*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[63] = det*w[5][0]*(2.0*K[0]*K[0]*K[0]*K[0] + K[1]*K[1]*(2.0*K[1]*K[1] + 4.0*K[0]*K[0]) + K[2]*K[2]*(2.0*K[2]*K[2] + 4.0*(K[0]*K[0] + K[1]*K[1])));
    G[64] = 6.0*det*w[5][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[65] = 6.0*det*w[5][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[66] = det*w[5][0]*(4.0*K[0]*K[0]*K[0]*K[0] + K[1]*K[1]*(4.0*K[1]*K[1] + 8.0*K[0]*K[0]) + K[2]*K[2]*(4.0*K[2]*K[2] + 8.0*(K[0]*K[0] + K[1]*K[1])));
    G[67] = 4.0*det*w[5][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[68] = 4.0*det*w[5][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[69] = det*w[5][0]*(2.0*(K[3]*K[3]*(K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1])) + 6.0*K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(6.0*K[1]*K[4] + 8.0*K[0]*K[3]) + K[2]*K[5]*(6.0*K[2]*K[5] + 8.0*(K[0]*K[3] + K[1]*K[4])));
    G[70] = det*w[5][0]*(K[0]*K[0]*(12.0*K[3]*K[6] + 4.0*(K[4]*K[7] + K[5]*K[8])) + K[1]*(8.0*K[0]*(K[3]*K[7] + K[4]*K[6]) + K[1]*(12.0*K[4]*K[7] + 4.0*(K[3]*K[6] + K[5]*K[8]))) + K[2]*(8.0*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(12.0*K[5]*K[8] + 4.0*(K[3]*K[6] + K[4]*K[7]))));
    G[71] = 8.0*det*w[5][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[72] = det*w[5][0]*(2.0*(K[3]*K[3]*(K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1])) + 8.0*K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(12.0*K[0]*K[3] + 8.0*K[1]*K[4]) + K[2]*K[5]*(12.0*(K[0]*K[3] + K[1]*K[4]) + 8.0*K[2]*K[5]));
    G[73] = det*w[5][0]*(K[0]*K[0]*(2.0*(K[4]*K[7] + K[5]*K[8]) + 8.0*K[3]*K[6]) + K[1]*(6.0*K[0]*(K[3]*K[7] + K[4]*K[6]) + K[1]*(2.0*(K[3]*K[6] + K[5]*K[8]) + 8.0*K[4]*K[7])) + K[2]*(6.0*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(2.0*(K[3]*K[6] + K[4]*K[7]) + 8.0*K[5]*K[8])));
    G[74] = det*w[5][0]*(2.0*(K[6]*K[6]*(K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1])) + 6.0*K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(6.0*K[1]*K[7] + 8.0*K[0]*K[6]) + K[2]*K[8]*(6.0*K[2]*K[8] + 8.0*(K[0]*K[6] + K[1]*K[7])));
    G[75] = 8.0*det*w[5][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[76] = det*w[5][0]*(2.0*(K[6]*K[6]*(K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1])) + 8.0*K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(12.0*K[0]*K[6] + 8.0*K[1]*K[7]) + K[2]*K[8]*(12.0*(K[0]*K[6] + K[1]*K[7]) + 8.0*K[2]*K[8]));
    G[77] = det*w[5][0]*w[5][0]*(K[1]*K[1]*(-2.0*K[1]*K[1]-4.0*K[0]*K[0]) + K[2]*K[2]*(-2.0*K[2]*K[2]-4.0*(K[0]*K[0] + K[1]*K[1]))-2.0*K[0]*K[0]*K[0]*K[0]);
    G[78] = -2.0*det*w[5][0]*w[5][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[79] = -2.0*det*w[5][0]*w[5][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[80] = det*w[5][0]*(K[1]*K[1]*(-2.0*K[1]*K[1]-4.0*K[0]*K[0]) + K[2]*K[2]*(-2.0*K[2]*K[2]-4.0*(K[0]*K[0] + K[1]*K[1]))-2.0*K[0]*K[0]*K[0]*K[0]);
    G[81] = -4.0*det*w[5][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[82] = -4.0*det*w[5][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[83] = -2.0*det*w[5][0]*(K[3]*K[3]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[84] = -4.0*det*w[5][0]*(K[3]*K[6]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[4]*K[7]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[5]*K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[85] = -2.0*det*w[5][0]*w[5][0]*(K[3]*K[3]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[86] = -2.0*det*w[5][0]*w[5][0]*(K[3]*K[6]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[4]*K[7]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[5]*K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[87] = -2.0*det*w[5][0]*(K[6]*K[6]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[88] = -2.0*det*w[5][0]*w[5][0]*(K[6]*K[6]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[89] = -2.0*det*w[5][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[90] = -2.0*det*w[5][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[91] = -2.0*det*w[5][0]*(K[3]*K[6]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[4]*K[7]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[5]*K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[92] = det*w[5][0]*(2.0*K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(2.0*K[1]*K[4] + 4.0*K[0]*K[3]) + K[2]*K[5]*(2.0*K[2]*K[5] + 4.0*(K[0]*K[3] + K[1]*K[4])));
    G[93] = 4.0*det*w[5][0]*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[94] = det*w[5][0]*(2.0*K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(2.0*K[1]*K[7] + 4.0*K[0]*K[6]) + K[2]*K[8]*(2.0*K[2]*K[8] + 4.0*(K[0]*K[6] + K[1]*K[7])));
    G[95] = 2.0*det*w[5][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[96] = det*w[5][0]*(K[3]*K[3]*(2.0*(K[1]*K[7] + K[2]*K[8]) + 6.0*K[0]*K[6]) + K[4]*(4.0*K[3]*(K[0]*K[7] + K[1]*K[6]) + K[4]*(2.0*(K[0]*K[6] + K[2]*K[8]) + 6.0*K[1]*K[7])) + K[5]*(4.0*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(2.0*(K[0]*K[6] + K[1]*K[7]) + 6.0*K[2]*K[8])));
    G[97] = det*w[5][0]*(2.0*(K[3]*K[3]*(K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1])) + 4.0*(K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(K[0]*K[3] + K[1]*K[4]) + K[2]*K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[98] = 4.0*det*w[5][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[99] = det*w[5][0]*(2.0*(K[3]*K[3]*(K[1]*K[7] + K[2]*K[8]) + K[4]*(K[0]*K[3]*K[7] + K[2]*K[4]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[5]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 4.0*(K[0]*K[3]*K[3]*K[6] + K[1]*K[4]*K[4]*K[7] + K[2]*K[5]*K[5]*K[8]));
    G[100] = det*w[5][0]*(K[6]*K[6]*(2.0*(K[1]*K[4] + K[2]*K[5]) + 6.0*K[0]*K[3]) + K[7]*(4.0*K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(2.0*(K[0]*K[3] + K[2]*K[5]) + 6.0*K[1]*K[4])) + K[8]*(4.0*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4])) + K[8]*(2.0*(K[0]*K[3] + K[1]*K[4]) + 6.0*K[2]*K[5])));
    G[101] = det*w[5][0]*(4.0*(K[0]*K[0]*(K[4]*K[7] + K[5]*K[8]) + K[1]*(K[0]*K[3]*K[7] + K[1]*K[5]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[2]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 8.0*(K[0]*K[0]*K[3]*K[6] + K[1]*K[1]*K[4]*K[7] + K[2]*K[2]*K[5]*K[8]));
    G[102] = det*w[5][0]*(K[3]*K[3]*(2.0*(K[1]*K[7] + K[2]*K[8]) + 8.0*K[0]*K[6]) + K[4]*(6.0*K[3]*(K[0]*K[7] + K[1]*K[6]) + K[4]*(2.0*(K[0]*K[6] + K[2]*K[8]) + 8.0*K[1]*K[7])) + K[5]*(6.0*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(2.0*(K[0]*K[6] + K[1]*K[7]) + 8.0*K[2]*K[8])));
    G[103] = det*w[5][0]*(K[6]*K[6]*(2.0*(K[1]*K[4] + K[2]*K[5]) + 8.0*K[0]*K[3]) + K[7]*(6.0*K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(2.0*(K[0]*K[3] + K[2]*K[5]) + 8.0*K[1]*K[4])) + K[8]*(6.0*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4])) + K[8]*(2.0*(K[0]*K[3] + K[1]*K[4]) + 8.0*K[2]*K[5])));
    G[104] = det*w[5][0]*w[5][0]*(K[1]*K[4]*(-2.0*K[1]*K[4]-4.0*K[0]*K[3]) + K[2]*K[5]*(-2.0*K[2]*K[5]-4.0*(K[0]*K[3] + K[1]*K[4]))-2.0*K[0]*K[0]*K[3]*K[3]);
    G[105] = -2.0*det*w[5][0]*w[5][0]*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[106] = det*w[5][0]*(K[1]*K[4]*(-4.0*K[1]*K[4]-8.0*K[0]*K[3]) + K[2]*K[5]*(-4.0*K[2]*K[5]-8.0*(K[0]*K[3] + K[1]*K[4]))-4.0*K[0]*K[0]*K[3]*K[3]);
    G[107] = -4.0*det*w[5][0]*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[108] = -2.0*det*w[5][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[109] = -4.0*det*w[5][0]*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[110] = -2.0*det*w[5][0]*w[5][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[111] = -2.0*det*w[5][0]*w[5][0]*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[112] = -2.0*det*w[5][0]*(K[6]*K[6]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]) + K[7]*K[7]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]) + K[8]*K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]));
    G[113] = -2.0*det*w[5][0]*w[5][0]*(K[6]*K[6]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]) + K[7]*K[7]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]) + K[8]*K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]));
    G[114] = det*w[5][0]*(K[1]*K[4]*(-2.0*K[1]*K[4]-4.0*K[0]*K[3]) + K[2]*K[5]*(-2.0*K[2]*K[5]-4.0*(K[0]*K[3] + K[1]*K[4]))-2.0*K[0]*K[0]*K[3]*K[3]);
    G[115] = -2.0*det*w[5][0]*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[116] = -2.0*det*w[5][0]*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[117] = 2.0*det*w[5][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[118] = det*w[5][0]*(2.0*(K[0]*K[0]*(K[4]*K[7] + K[5]*K[8]) + K[1]*(K[0]*K[3]*K[7] + K[1]*K[5]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[2]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 4.0*(K[0]*K[0]*K[3]*K[6] + K[1]*K[1]*K[4]*K[7] + K[2]*K[2]*K[5]*K[8]));
    G[119] = 2.0*det*w[5][0]*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[120] = 2.0*det*w[5][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[121] = det*w[5][0]*(2.0*(K[6]*K[6]*(K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1])) + 4.0*(K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(K[0]*K[6] + K[1]*K[7]) + K[2]*K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[122] = det*w[5][0]*(2.0*(K[6]*K[6]*(K[1]*K[4] + K[2]*K[5]) + K[7]*(K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(K[0]*K[3] + K[2]*K[5])) + K[8]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 4.0*(K[0]*K[3]*K[6]*K[6] + K[1]*K[4]*K[7]*K[7] + K[2]*K[5]*K[8]*K[8]));
    G[123] = 4.0*det*w[5][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[124] = det*w[5][0]*w[5][0]*(K[1]*K[7]*(-2.0*K[1]*K[7]-4.0*K[0]*K[6]) + K[2]*K[8]*(-2.0*K[2]*K[8]-4.0*(K[0]*K[6] + K[1]*K[7]))-2.0*K[0]*K[0]*K[6]*K[6]);
    G[125] = det*w[5][0]*(K[1]*K[7]*(-4.0*K[1]*K[7]-8.0*K[0]*K[6]) + K[2]*K[8]*(-4.0*K[2]*K[8]-8.0*(K[0]*K[6] + K[1]*K[7]))-4.0*K[0]*K[0]*K[6]*K[6]);
    G[126] = -2.0*det*w[5][0]*(K[3]*K[3]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]) + K[4]*K[4]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]) + K[5]*K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]));
    G[127] = -4.0*det*w[5][0]*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[128] = -2.0*det*w[5][0]*w[5][0]*(K[3]*K[3]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]) + K[4]*K[4]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]) + K[5]*K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]));
    G[129] = -2.0*det*w[5][0]*w[5][0]*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[130] = -2.0*det*w[5][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[131] = -2.0*det*w[5][0]*w[5][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[132] = det*w[5][0]*(K[1]*K[7]*(-2.0*K[1]*K[7]-4.0*K[0]*K[6]) + K[2]*K[8]*(-2.0*K[2]*K[8]-4.0*(K[0]*K[6] + K[1]*K[7]))-2.0*K[0]*K[0]*K[6]*K[6]);
    G[133] = -2.0*det*w[5][0]*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[134] = 2.0*det*w[5][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[135] = 2.0*det*w[5][0]*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[136] = -4.0*det*w[5][0]*w[5][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[137] = det*w[5][0]*(-2.0*(K[3]*K[3]*(K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1]))-4.0*(K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(K[0]*K[3] + K[1]*K[4]) + K[2]*K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[138] = det*w[5][0]*(-2.0*(K[0]*K[0]*(K[4]*K[7] + K[5]*K[8]) + K[1]*(K[0]*K[3]*K[7] + K[1]*K[5]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[2]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4])))-4.0*(K[0]*K[0]*K[3]*K[6] + K[1]*K[1]*K[4]*K[7] + K[2]*K[2]*K[5]*K[8]));
    G[139] = det*w[5][0]*w[5][0]*(-2.0*(K[3]*K[3]*(K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1]))-4.0*(K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(K[0]*K[3] + K[1]*K[4]) + K[2]*K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[140] = det*w[5][0]*w[5][0]*(-2.0*(K[0]*K[0]*(K[4]*K[7] + K[5]*K[8]) + K[1]*(K[0]*K[3]*K[7] + K[1]*K[5]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[2]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4])))-4.0*(K[0]*K[0]*K[3]*K[6] + K[1]*K[1]*K[4]*K[7] + K[2]*K[2]*K[5]*K[8]));
    G[141] = -4.0*det*w[5][0]*w[5][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[142] = det*w[5][0]*(-2.0*(K[6]*K[6]*(K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1]))-4.0*(K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(K[0]*K[6] + K[1]*K[7]) + K[2]*K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[143] = det*w[5][0]*w[5][0]*(-2.0*(K[6]*K[6]*(K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1]))-4.0*(K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(K[0]*K[6] + K[1]*K[7]) + K[2]*K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[144] = -4.0*det*w[5][0]*w[5][0]*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[145] = det*w[5][0]*(-2.0*(K[3]*K[3]*(K[1]*K[7] + K[2]*K[8]) + K[4]*(K[0]*K[3]*K[7] + K[2]*K[4]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[5]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4])))-4.0*(K[0]*K[3]*K[3]*K[6] + K[1]*K[4]*K[4]*K[7] + K[2]*K[5]*K[5]*K[8]));
    G[146] = det*w[5][0]*(-2.0*(K[6]*K[6]*(K[1]*K[4] + K[2]*K[5]) + K[7]*(K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(K[0]*K[3] + K[2]*K[5])) + K[8]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4])))-4.0*(K[0]*K[3]*K[6]*K[6] + K[1]*K[4]*K[7]*K[7] + K[2]*K[5]*K[8]*K[8]));
    G[147] = det*w[5][0]*w[5][0]*(-2.0*(K[3]*K[3]*(K[1]*K[7] + K[2]*K[8]) + K[4]*(K[0]*K[3]*K[7] + K[2]*K[4]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[5]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4])))-4.0*(K[0]*K[3]*K[3]*K[6] + K[1]*K[4]*K[4]*K[7] + K[2]*K[5]*K[5]*K[8]));
    G[148] = det*w[5][0]*w[5][0]*(-2.0*(K[6]*K[6]*(K[1]*K[4] + K[2]*K[5]) + K[7]*(K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(K[0]*K[3] + K[2]*K[5])) + K[8]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4])))-4.0*(K[0]*K[3]*K[6]*K[6] + K[1]*K[4]*K[7]*K[7] + K[2]*K[5]*K[8]*K[8]));
    G[149] = det*w[7][0]*w[7][0]*(K[1]*K[1]*(-2.0*K[1]*K[1]-4.0*K[0]*K[0]) + K[2]*K[2]*(-2.0*K[2]*K[2]-4.0*(K[0]*K[0] + K[1]*K[1]))-2.0*K[0]*K[0]*K[0]*K[0]);
    G[150] = -2.0*det*w[7][0]*w[7][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[151] = -2.0*det*w[7][0]*w[7][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[152] = det*w[7][0]*w[7][0]*(K[1]*K[4]*(-2.0*K[1]*K[4]-4.0*K[0]*K[3]) + K[2]*K[5]*(-2.0*K[2]*K[5]-4.0*(K[0]*K[3] + K[1]*K[4]))-2.0*K[0]*K[0]*K[3]*K[3]);
    G[153] = -2.0*det*w[7][0]*w[7][0]*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[154] = det*w[7][0]*w[7][0]*(K[1]*K[7]*(-2.0*K[1]*K[7]-4.0*K[0]*K[6]) + K[2]*K[8]*(-2.0*K[2]*K[8]-4.0*(K[0]*K[6] + K[1]*K[7]))-2.0*K[0]*K[0]*K[6]*K[6]);
    G[155] = -4.0*det*w[7][0]*w[7][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[156] = -4.0*det*w[7][0]*w[7][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[157] = -4.0*det*w[7][0]*w[7][0]*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[158] = det*(K[1]*K[1]*(-2.0*K[1]*K[1]-4.0*K[0]*K[0]) + K[2]*K[2]*(-2.0*K[2]*K[2]-4.0*(K[0]*K[0] + K[1]*K[1]))-2.0*K[0]*K[0]*K[0]*K[0]);
    G[159] = -4.0*det*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[160] = -4.0*det*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[161] = det*(K[1]*K[4]*(-2.0*K[1]*K[4]-4.0*K[0]*K[3]) + K[2]*K[5]*(-2.0*K[2]*K[5]-4.0*(K[0]*K[3] + K[1]*K[4]))-2.0*K[0]*K[0]*K[3]*K[3]);
    G[162] = -4.0*det*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[163] = det*(K[1]*K[7]*(-2.0*K[1]*K[7]-4.0*K[0]*K[6]) + K[2]*K[8]*(-2.0*K[2]*K[8]-4.0*(K[0]*K[6] + K[1]*K[7]))-2.0*K[0]*K[0]*K[6]*K[6]);
    G[164] = det*w[7][0]*(2.0*K[0]*K[0]*K[0]*K[0] + K[1]*K[1]*(2.0*K[1]*K[1] + 4.0*K[0]*K[0]) + K[2]*K[2]*(2.0*K[2]*K[2] + 4.0*(K[0]*K[0] + K[1]*K[1])));
    G[165] = 6.0*det*w[7][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[166] = 6.0*det*w[7][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[167] = det*w[7][0]*(4.0*K[0]*K[0]*K[0]*K[0] + K[1]*K[1]*(4.0*K[1]*K[1] + 8.0*K[0]*K[0]) + K[2]*K[2]*(4.0*K[2]*K[2] + 8.0*(K[0]*K[0] + K[1]*K[1])));
    G[168] = 4.0*det*w[7][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[169] = 4.0*det*w[7][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[170] = det*w[7][0]*(2.0*(K[3]*K[3]*(K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1])) + 6.0*K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(6.0*K[1]*K[4] + 8.0*K[0]*K[3]) + K[2]*K[5]*(6.0*K[2]*K[5] + 8.0*(K[0]*K[3] + K[1]*K[4])));
    G[171] = det*w[7][0]*(K[0]*K[0]*(12.0*K[3]*K[6] + 4.0*(K[4]*K[7] + K[5]*K[8])) + K[1]*(8.0*K[0]*(K[3]*K[7] + K[4]*K[6]) + K[1]*(12.0*K[4]*K[7] + 4.0*(K[3]*K[6] + K[5]*K[8]))) + K[2]*(8.0*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(12.0*K[5]*K[8] + 4.0*(K[3]*K[6] + K[4]*K[7]))));
    G[172] = 8.0*det*w[7][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[173] = det*w[7][0]*(2.0*(K[3]*K[3]*(K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1])) + 8.0*K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(12.0*K[0]*K[3] + 8.0*K[1]*K[4]) + K[2]*K[5]*(12.0*(K[0]*K[3] + K[1]*K[4]) + 8.0*K[2]*K[5]));
    G[174] = det*w[7][0]*(K[0]*K[0]*(2.0*(K[4]*K[7] + K[5]*K[8]) + 8.0*K[3]*K[6]) + K[1]*(6.0*K[0]*(K[3]*K[7] + K[4]*K[6]) + K[1]*(2.0*(K[3]*K[6] + K[5]*K[8]) + 8.0*K[4]*K[7])) + K[2]*(6.0*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(2.0*(K[3]*K[6] + K[4]*K[7]) + 8.0*K[5]*K[8])));
    G[175] = det*w[7][0]*(2.0*(K[6]*K[6]*(K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1])) + 6.0*K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(6.0*K[1]*K[7] + 8.0*K[0]*K[6]) + K[2]*K[8]*(6.0*K[2]*K[8] + 8.0*(K[0]*K[6] + K[1]*K[7])));
    G[176] = 8.0*det*w[7][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[177] = det*w[7][0]*(2.0*(K[6]*K[6]*(K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1])) + 8.0*K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(12.0*K[0]*K[6] + 8.0*K[1]*K[7]) + K[2]*K[8]*(12.0*(K[0]*K[6] + K[1]*K[7]) + 8.0*K[2]*K[8]));
    G[178] = -2.0*det*w[7][0]*w[7][0]*(K[3]*K[3]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[179] = -2.0*det*w[7][0]*w[7][0]*(K[3]*K[6]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[4]*K[7]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[5]*K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[180] = det*w[7][0]*(K[1]*K[1]*(-2.0*K[1]*K[1]-4.0*K[0]*K[0]) + K[2]*K[2]*(-2.0*K[2]*K[2]-4.0*(K[0]*K[0] + K[1]*K[1]))-2.0*K[0]*K[0]*K[0]*K[0]);
    G[181] = -4.0*det*w[7][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[182] = -4.0*det*w[7][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[183] = -2.0*det*w[7][0]*(K[3]*K[3]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[184] = -4.0*det*w[7][0]*(K[3]*K[6]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[4]*K[7]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[5]*K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[185] = -2.0*det*w[7][0]*(K[6]*K[6]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[186] = -2.0*det*w[7][0]*w[7][0]*(K[6]*K[6]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[187] = -2.0*det*w[7][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[188] = -2.0*det*w[7][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[189] = -2.0*det*w[7][0]*(K[3]*K[6]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[4]*K[7]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[5]*K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[190] = det*w[7][0]*(2.0*K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(2.0*K[1]*K[4] + 4.0*K[0]*K[3]) + K[2]*K[5]*(2.0*K[2]*K[5] + 4.0*(K[0]*K[3] + K[1]*K[4])));
    G[191] = 4.0*det*w[7][0]*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[192] = det*w[7][0]*(2.0*K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(2.0*K[1]*K[7] + 4.0*K[0]*K[6]) + K[2]*K[8]*(2.0*K[2]*K[8] + 4.0*(K[0]*K[6] + K[1]*K[7])));
    G[193] = 2.0*det*w[7][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[194] = det*w[7][0]*(K[3]*K[3]*(2.0*(K[1]*K[7] + K[2]*K[8]) + 6.0*K[0]*K[6]) + K[4]*(4.0*K[3]*(K[0]*K[7] + K[1]*K[6]) + K[4]*(2.0*(K[0]*K[6] + K[2]*K[8]) + 6.0*K[1]*K[7])) + K[5]*(4.0*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(2.0*(K[0]*K[6] + K[1]*K[7]) + 6.0*K[2]*K[8])));
    G[195] = det*w[7][0]*(2.0*(K[3]*K[3]*(K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1])) + 4.0*(K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(K[0]*K[3] + K[1]*K[4]) + K[2]*K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[196] = 4.0*det*w[7][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[197] = det*w[7][0]*(2.0*(K[3]*K[3]*(K[1]*K[7] + K[2]*K[8]) + K[4]*(K[0]*K[3]*K[7] + K[2]*K[4]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[5]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 4.0*(K[0]*K[3]*K[3]*K[6] + K[1]*K[4]*K[4]*K[7] + K[2]*K[5]*K[5]*K[8]));
    G[198] = det*w[7][0]*(K[6]*K[6]*(2.0*(K[1]*K[4] + K[2]*K[5]) + 6.0*K[0]*K[3]) + K[7]*(4.0*K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(2.0*(K[0]*K[3] + K[2]*K[5]) + 6.0*K[1]*K[4])) + K[8]*(4.0*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4])) + K[8]*(2.0*(K[0]*K[3] + K[1]*K[4]) + 6.0*K[2]*K[5])));
    G[199] = det*w[7][0]*(4.0*(K[0]*K[0]*(K[4]*K[7] + K[5]*K[8]) + K[1]*(K[0]*K[3]*K[7] + K[1]*K[5]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[2]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 8.0*(K[0]*K[0]*K[3]*K[6] + K[1]*K[1]*K[4]*K[7] + K[2]*K[2]*K[5]*K[8]));
    G[200] = det*w[7][0]*(K[3]*K[3]*(2.0*(K[1]*K[7] + K[2]*K[8]) + 8.0*K[0]*K[6]) + K[4]*(6.0*K[3]*(K[0]*K[7] + K[1]*K[6]) + K[4]*(2.0*(K[0]*K[6] + K[2]*K[8]) + 8.0*K[1]*K[7])) + K[5]*(6.0*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(2.0*(K[0]*K[6] + K[1]*K[7]) + 8.0*K[2]*K[8])));
    G[201] = det*w[7][0]*(K[6]*K[6]*(2.0*(K[1]*K[4] + K[2]*K[5]) + 8.0*K[0]*K[3]) + K[7]*(6.0*K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(2.0*(K[0]*K[3] + K[2]*K[5]) + 8.0*K[1]*K[4])) + K[8]*(6.0*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4])) + K[8]*(2.0*(K[0]*K[3] + K[1]*K[4]) + 8.0*K[2]*K[5])));
    G[202] = -2.0*det*w[7][0]*w[7][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[203] = -2.0*det*w[7][0]*w[7][0]*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[204] = det*w[7][0]*(K[1]*K[4]*(-4.0*K[1]*K[4]-8.0*K[0]*K[3]) + K[2]*K[5]*(-4.0*K[2]*K[5]-8.0*(K[0]*K[3] + K[1]*K[4]))-4.0*K[0]*K[0]*K[3]*K[3]);
    G[205] = -4.0*det*w[7][0]*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[206] = -2.0*det*w[7][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[207] = -4.0*det*w[7][0]*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[208] = -2.0*det*w[7][0]*(K[6]*K[6]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]) + K[7]*K[7]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]) + K[8]*K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]));
    G[209] = -2.0*det*w[7][0]*w[7][0]*(K[6]*K[6]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]) + K[7]*K[7]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]) + K[8]*K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]));
    G[210] = det*w[7][0]*(K[1]*K[4]*(-2.0*K[1]*K[4]-4.0*K[0]*K[3]) + K[2]*K[5]*(-2.0*K[2]*K[5]-4.0*(K[0]*K[3] + K[1]*K[4]))-2.0*K[0]*K[0]*K[3]*K[3]);
    G[211] = -2.0*det*w[7][0]*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[212] = -2.0*det*w[7][0]*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[213] = 2.0*det*w[7][0]*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[214] = det*w[7][0]*(2.0*(K[0]*K[0]*(K[4]*K[7] + K[5]*K[8]) + K[1]*(K[0]*K[3]*K[7] + K[1]*K[5]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[2]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 4.0*(K[0]*K[0]*K[3]*K[6] + K[1]*K[1]*K[4]*K[7] + K[2]*K[2]*K[5]*K[8]));
    G[215] = 2.0*det*w[7][0]*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[216] = 2.0*det*w[7][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[217] = det*w[7][0]*(2.0*(K[6]*K[6]*(K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1])) + 4.0*(K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(K[0]*K[6] + K[1]*K[7]) + K[2]*K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[218] = det*w[7][0]*(2.0*(K[6]*K[6]*(K[1]*K[4] + K[2]*K[5]) + K[7]*(K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(K[0]*K[3] + K[2]*K[5])) + K[8]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 4.0*(K[0]*K[3]*K[6]*K[6] + K[1]*K[4]*K[7]*K[7] + K[2]*K[5]*K[8]*K[8]));
    G[219] = 4.0*det*w[7][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[220] = -2.0*det*w[7][0]*w[7][0]*(K[3]*K[3]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]) + K[4]*K[4]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]) + K[5]*K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]));
    G[221] = -2.0*det*w[7][0]*w[7][0]*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[222] = det*w[7][0]*(K[1]*K[7]*(-4.0*K[1]*K[7]-8.0*K[0]*K[6]) + K[2]*K[8]*(-4.0*K[2]*K[8]-8.0*(K[0]*K[6] + K[1]*K[7]))-4.0*K[0]*K[0]*K[6]*K[6]);
    G[223] = -2.0*det*w[7][0]*(K[3]*K[3]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]) + K[4]*K[4]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]) + K[5]*K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]));
    G[224] = -4.0*det*w[7][0]*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[225] = -2.0*det*w[7][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[226] = -2.0*det*w[7][0]*w[7][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[227] = det*w[7][0]*(K[1]*K[7]*(-2.0*K[1]*K[7]-4.0*K[0]*K[6]) + K[2]*K[8]*(-2.0*K[2]*K[8]-4.0*(K[0]*K[6] + K[1]*K[7]))-2.0*K[0]*K[0]*K[6]*K[6]);
    G[228] = -2.0*det*w[7][0]*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[229] = 2.0*det*w[7][0]*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[230] = 2.0*det*w[7][0]*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[231] = det*w[7][0]*w[7][0]*(-2.0*(K[3]*K[3]*(K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1]))-4.0*(K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(K[0]*K[3] + K[1]*K[4]) + K[2]*K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[232] = det*w[7][0]*(-2.0*(K[3]*K[3]*(K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1]))-4.0*(K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(K[0]*K[3] + K[1]*K[4]) + K[2]*K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[233] = det*w[7][0]*(-2.0*(K[0]*K[0]*(K[4]*K[7] + K[5]*K[8]) + K[1]*(K[0]*K[3]*K[7] + K[1]*K[5]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[2]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4])))-4.0*(K[0]*K[0]*K[3]*K[6] + K[1]*K[1]*K[4]*K[7] + K[2]*K[2]*K[5]*K[8]));
    G[234] = det*w[7][0]*w[7][0]*(-2.0*(K[0]*K[0]*(K[4]*K[7] + K[5]*K[8]) + K[1]*(K[0]*K[3]*K[7] + K[1]*K[5]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[2]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4])))-4.0*(K[0]*K[0]*K[3]*K[6] + K[1]*K[1]*K[4]*K[7] + K[2]*K[2]*K[5]*K[8]));
    G[235] = det*w[7][0]*(-2.0*(K[6]*K[6]*(K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1]))-4.0*(K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(K[0]*K[6] + K[1]*K[7]) + K[2]*K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[236] = det*w[7][0]*w[7][0]*(-2.0*(K[6]*K[6]*(K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1]))-4.0*(K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(K[0]*K[6] + K[1]*K[7]) + K[2]*K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[237] = det*w[7][0]*w[7][0]*(-2.0*(K[3]*K[3]*(K[1]*K[7] + K[2]*K[8]) + K[4]*(K[0]*K[3]*K[7] + K[2]*K[4]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[5]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4])))-4.0*(K[0]*K[3]*K[3]*K[6] + K[1]*K[4]*K[4]*K[7] + K[2]*K[5]*K[5]*K[8]));
    G[238] = det*w[7][0]*(-2.0*(K[3]*K[3]*(K[1]*K[7] + K[2]*K[8]) + K[4]*(K[0]*K[3]*K[7] + K[2]*K[4]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[5]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4])))-4.0*(K[0]*K[3]*K[3]*K[6] + K[1]*K[4]*K[4]*K[7] + K[2]*K[5]*K[5]*K[8]));
    G[239] = det*w[7][0]*(-2.0*(K[6]*K[6]*(K[1]*K[4] + K[2]*K[5]) + K[7]*(K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(K[0]*K[3] + K[2]*K[5])) + K[8]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4])))-4.0*(K[0]*K[3]*K[6]*K[6] + K[1]*K[4]*K[7]*K[7] + K[2]*K[5]*K[8]*K[8]));
    G[240] = det*w[7][0]*w[7][0]*(-2.0*(K[6]*K[6]*(K[1]*K[4] + K[2]*K[5]) + K[7]*(K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(K[0]*K[3] + K[2]*K[5])) + K[8]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4])))-4.0*(K[0]*K[3]*K[6]*K[6] + K[1]*K[4]*K[7]*K[7] + K[2]*K[5]*K[8]*K[8]));
    G[241] = -2.0*det*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[242] = det*(-2.0*(K[3]*K[3]*(K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1]))-4.0*(K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(K[0]*K[3] + K[1]*K[4]) + K[2]*K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[243] = det*(-2.0*(K[0]*K[0]*(K[4]*K[7] + K[5]*K[8]) + K[1]*(K[0]*K[3]*K[7] + K[1]*K[5]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[2]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4])))-4.0*(K[0]*K[0]*K[3]*K[6] + K[1]*K[1]*K[4]*K[7] + K[2]*K[2]*K[5]*K[8]));
    G[244] = -2.0*det*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[245] = det*(-2.0*(K[3]*K[3]*(K[1]*K[7] + K[2]*K[8]) + K[4]*(K[0]*K[3]*K[7] + K[2]*K[4]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[5]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4])))-4.0*(K[0]*K[3]*K[3]*K[6] + K[1]*K[4]*K[4]*K[7] + K[2]*K[5]*K[5]*K[8]));
    G[246] = -2.0*det*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[247] = -2.0*det*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[248] = det*(-2.0*(K[6]*K[6]*(K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1]))-4.0*(K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(K[0]*K[6] + K[1]*K[7]) + K[2]*K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[249] = -2.0*det*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[250] = det*(-2.0*(K[6]*K[6]*(K[1]*K[4] + K[2]*K[5]) + K[7]*(K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(K[0]*K[3] + K[2]*K[5])) + K[8]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4])))-4.0*(K[0]*K[3]*K[6]*K[6] + K[1]*K[4]*K[7]*K[7] + K[2]*K[5]*K[8]*K[8]));
    G[251] = -2.0*det*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[252] = -2.0*det*w[5][0]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]);
    G[253] = -2.0*det*w[7][0]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]);
    G[254] = 2.0*det*w[7][0]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]);
    G[255] = 2.0*det*w[5][0]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]);
    G[256] = -2.0*det*w[5][0]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]);
    G[257] = -2.0*det*w[7][0]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]);
    G[258] = 2.0*det*w[7][0]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]);
    G[259] = 2.0*det*w[5][0]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]);
    G[260] = -2.0*det*w[5][0]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]);
    G[261] = -2.0*det*w[7][0]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]);
    G[262] = 2.0*det*w[7][0]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]);
    G[263] = 2.0*det*w[5][0]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]);
    G[264] = det*w[5][0]*w[5][0]*(K[3]*K[3]*K[3]*K[3] + K[4]*K[4]*(2.0*K[3]*K[3] + K[4]*K[4]) + K[5]*K[5]*(2.0*(K[3]*K[3] + K[4]*K[4]) + K[5]*K[5]));
    G[265] = 2.0*det*w[5][0]*w[5][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[266] = det*w[5][0]*w[5][0]*(2.0*K[3]*K[3]*K[3]*K[3] + K[4]*K[4]*(2.0*K[4]*K[4] + 4.0*K[3]*K[3]) + K[5]*K[5]*(2.0*K[5]*K[5] + 4.0*(K[3]*K[3] + K[4]*K[4])));
    G[267] = det*w[5][0]*w[5][0]*(K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(2.0*K[3]*K[6] + K[4]*K[7]) + K[5]*K[8]*(2.0*(K[3]*K[6] + K[4]*K[7]) + K[5]*K[8]));
    G[268] = det*w[5][0]*w[5][0]*(2.0*K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(2.0*K[4]*K[7] + 4.0*K[3]*K[6]) + K[5]*K[8]*(2.0*K[5]*K[8] + 4.0*(K[3]*K[6] + K[4]*K[7])));
    G[269] = det*w[7][0]*w[7][0]*(K[3]*K[3]*K[3]*K[3] + K[4]*K[4]*(2.0*K[3]*K[3] + K[4]*K[4]) + K[5]*K[5]*(2.0*(K[3]*K[3] + K[4]*K[4]) + K[5]*K[5]));
    G[270] = 2.0*det*w[7][0]*w[7][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[271] = det*w[7][0]*w[7][0]*(2.0*K[3]*K[3]*K[3]*K[3] + K[4]*K[4]*(2.0*K[4]*K[4] + 4.0*K[3]*K[3]) + K[5]*K[5]*(2.0*K[5]*K[5] + 4.0*(K[3]*K[3] + K[4]*K[4])));
    G[272] = det*w[7][0]*w[7][0]*(K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(2.0*K[3]*K[6] + K[4]*K[7]) + K[5]*K[8]*(2.0*(K[3]*K[6] + K[4]*K[7]) + K[5]*K[8]));
    G[273] = det*w[7][0]*w[7][0]*(2.0*K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(2.0*K[4]*K[7] + 4.0*K[3]*K[6]) + K[5]*K[8]*(2.0*K[5]*K[8] + 4.0*(K[3]*K[6] + K[4]*K[7])));
    G[274] = det*(K[3]*K[3]*K[3]*K[3] + K[4]*K[4]*(2.0*K[3]*K[3] + K[4]*K[4]) + K[5]*K[5]*(2.0*(K[3]*K[3] + K[4]*K[4]) + K[5]*K[5]));
    G[275] = 2.0*det*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[276] = det*(K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(2.0*K[3]*K[6] + K[4]*K[7]) + K[5]*K[8]*(2.0*(K[3]*K[6] + K[4]*K[7]) + K[5]*K[8]));
    G[277] = 4.0*det*w[5][0]*w[5][0]*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[278] = det*w[5][0]*w[5][0]*(2.0*(K[6]*K[6]*(K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4])) + 4.0*(K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(K[3]*K[6] + K[4]*K[7]) + K[5]*K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[279] = 4.0*det*w[5][0]*w[5][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[280] = 2.0*det*w[5][0]*w[5][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[281] = 4.0*det*w[5][0]*w[5][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[282] = 4.0*det*w[7][0]*w[7][0]*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[283] = det*w[7][0]*w[7][0]*(2.0*(K[6]*K[6]*(K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4])) + 4.0*(K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(K[3]*K[6] + K[4]*K[7]) + K[5]*K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[284] = 4.0*det*w[7][0]*w[7][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[285] = 2.0*det*w[7][0]*w[7][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[286] = 4.0*det*w[7][0]*w[7][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[287] = det*(2.0*(K[6]*K[6]*(K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4])) + 4.0*(K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(K[3]*K[6] + K[4]*K[7]) + K[5]*K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[288] = 2.0*det*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[289] = det*w[5][0]*(K[0]*K[0]*(2.0*(K[4]*K[7] + K[5]*K[8]) + 6.0*K[3]*K[6]) + K[1]*(4.0*K[0]*(K[3]*K[7] + K[4]*K[6]) + K[1]*(2.0*(K[3]*K[6] + K[5]*K[8]) + 6.0*K[4]*K[7])) + K[2]*(4.0*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(2.0*(K[3]*K[6] + K[4]*K[7]) + 6.0*K[5]*K[8])));
    G[290] = 6.0*det*w[5][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[291] = det*w[5][0]*(K[3]*K[3]*(12.0*K[0]*K[6] + 4.0*(K[1]*K[7] + K[2]*K[8])) + K[4]*(8.0*K[3]*(K[0]*K[7] + K[1]*K[6]) + K[4]*(12.0*K[1]*K[7] + 4.0*(K[0]*K[6] + K[2]*K[8]))) + K[5]*(8.0*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(12.0*K[2]*K[8] + 4.0*(K[0]*K[6] + K[1]*K[7]))));
    G[292] = 8.0*det*w[5][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[293] = det*w[5][0]*(4.0*(K[3]*K[3]*(K[1]*K[7] + K[2]*K[8]) + K[4]*(K[0]*K[3]*K[7] + K[2]*K[4]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[5]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 8.0*(K[0]*K[3]*K[3]*K[6] + K[1]*K[4]*K[4]*K[7] + K[2]*K[5]*K[5]*K[8]));
    G[294] = det*w[5][0]*(2.0*K[3]*K[3]*K[3]*K[3] + K[4]*K[4]*(2.0*K[4]*K[4] + 4.0*K[3]*K[3]) + K[5]*K[5]*(2.0*K[5]*K[5] + 4.0*(K[3]*K[3] + K[4]*K[4])));
    G[295] = 6.0*det*w[5][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[296] = det*w[5][0]*(4.0*K[3]*K[3]*K[3]*K[3] + K[4]*K[4]*(4.0*K[4]*K[4] + 8.0*K[3]*K[3]) + K[5]*K[5]*(4.0*K[5]*K[5] + 8.0*(K[3]*K[3] + K[4]*K[4])));
    G[297] = 4.0*det*w[5][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[298] = det*w[5][0]*(2.0*(K[6]*K[6]*(K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4])) + 6.0*K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(6.0*K[4]*K[7] + 8.0*K[3]*K[6]) + K[5]*K[8]*(6.0*K[5]*K[8] + 8.0*(K[3]*K[6] + K[4]*K[7])));
    G[299] = 8.0*det*w[5][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[300] = det*w[5][0]*(2.0*(K[6]*K[6]*(K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4])) + 8.0*K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(12.0*K[3]*K[6] + 8.0*K[4]*K[7]) + K[5]*K[8]*(12.0*(K[3]*K[6] + K[4]*K[7]) + 8.0*K[5]*K[8]));
    G[301] = -4.0*det*w[5][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[302] = -4.0*det*w[5][0]*(K[3]*K[3]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]) + K[4]*K[4]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]) + K[5]*K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]));
    G[303] = det*w[5][0]*(K[4]*K[4]*(-2.0*K[4]*K[4]-4.0*K[3]*K[3]) + K[5]*K[5]*(-2.0*K[5]*K[5]-4.0*(K[3]*K[3] + K[4]*K[4]))-2.0*K[3]*K[3]*K[3]*K[3]);
    G[304] = -4.0*det*w[5][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[305] = det*w[5][0]*w[5][0]*(K[4]*K[4]*(-2.0*K[4]*K[4]-4.0*K[3]*K[3]) + K[5]*K[5]*(-2.0*K[5]*K[5]-4.0*(K[3]*K[3] + K[4]*K[4]))-2.0*K[3]*K[3]*K[3]*K[3]);
    G[306] = -2.0*det*w[5][0]*w[5][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[307] = -2.0*det*w[5][0]*(K[6]*K[6]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]));
    G[308] = -2.0*det*w[5][0]*w[5][0]*(K[6]*K[6]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]));
    G[309] = -2.0*det*w[5][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[310] = 4.0*det*w[5][0]*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[311] = det*w[5][0]*(2.0*K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(2.0*K[4]*K[7] + 4.0*K[3]*K[6]) + K[5]*K[8]*(2.0*K[5]*K[8] + 4.0*(K[3]*K[6] + K[4]*K[7])));
    G[312] = 2.0*det*w[5][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[313] = det*w[5][0]*(2.0*(K[6]*K[6]*(K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4])) + 4.0*(K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(K[3]*K[6] + K[4]*K[7]) + K[5]*K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[314] = 4.0*det*w[5][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[315] = det*w[5][0]*(K[4]*K[7]*(-4.0*K[4]*K[7]-8.0*K[3]*K[6]) + K[5]*K[8]*(-4.0*K[5]*K[8]-8.0*(K[3]*K[6] + K[4]*K[7]))-4.0*K[3]*K[3]*K[6]*K[6]);
    G[316] = det*w[5][0]*w[5][0]*(K[4]*K[7]*(-2.0*K[4]*K[7]-4.0*K[3]*K[6]) + K[5]*K[8]*(-2.0*K[5]*K[8]-4.0*(K[3]*K[6] + K[4]*K[7]))-2.0*K[3]*K[3]*K[6]*K[6]);
    G[317] = -2.0*det*w[5][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[318] = -2.0*det*w[5][0]*w[5][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[319] = det*w[5][0]*(K[4]*K[7]*(-2.0*K[4]*K[7]-4.0*K[3]*K[6]) + K[5]*K[8]*(-2.0*K[5]*K[8]-4.0*(K[3]*K[6] + K[4]*K[7]))-2.0*K[3]*K[3]*K[6]*K[6]);
    G[320] = 2.0*det*w[5][0]*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[321] = 2.0*det*w[5][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[322] = -4.0*det*w[5][0]*w[5][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[323] = -4.0*det*w[5][0]*w[5][0]*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[324] = det*w[5][0]*(-2.0*(K[6]*K[6]*(K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4]))-4.0*(K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(K[3]*K[6] + K[4]*K[7]) + K[5]*K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[325] = -4.0*det*w[5][0]*w[5][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[326] = det*w[5][0]*w[5][0]*(-2.0*(K[6]*K[6]*(K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4]))-4.0*(K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(K[3]*K[6] + K[4]*K[7]) + K[5]*K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[327] = det*w[7][0]*(K[0]*K[0]*(2.0*(K[4]*K[7] + K[5]*K[8]) + 6.0*K[3]*K[6]) + K[1]*(4.0*K[0]*(K[3]*K[7] + K[4]*K[6]) + K[1]*(2.0*(K[3]*K[6] + K[5]*K[8]) + 6.0*K[4]*K[7])) + K[2]*(4.0*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(2.0*(K[3]*K[6] + K[4]*K[7]) + 6.0*K[5]*K[8])));
    G[328] = 6.0*det*w[7][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[329] = det*w[7][0]*(K[3]*K[3]*(12.0*K[0]*K[6] + 4.0*(K[1]*K[7] + K[2]*K[8])) + K[4]*(8.0*K[3]*(K[0]*K[7] + K[1]*K[6]) + K[4]*(12.0*K[1]*K[7] + 4.0*(K[0]*K[6] + K[2]*K[8]))) + K[5]*(8.0*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(12.0*K[2]*K[8] + 4.0*(K[0]*K[6] + K[1]*K[7]))));
    G[330] = 8.0*det*w[7][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[331] = det*w[7][0]*(4.0*(K[3]*K[3]*(K[1]*K[7] + K[2]*K[8]) + K[4]*(K[0]*K[3]*K[7] + K[2]*K[4]*K[8] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[5]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 8.0*(K[0]*K[3]*K[3]*K[6] + K[1]*K[4]*K[4]*K[7] + K[2]*K[5]*K[5]*K[8]));
    G[332] = det*w[7][0]*(2.0*K[3]*K[3]*K[3]*K[3] + K[4]*K[4]*(2.0*K[4]*K[4] + 4.0*K[3]*K[3]) + K[5]*K[5]*(2.0*K[5]*K[5] + 4.0*(K[3]*K[3] + K[4]*K[4])));
    G[333] = 6.0*det*w[7][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[334] = det*w[7][0]*(4.0*K[3]*K[3]*K[3]*K[3] + K[4]*K[4]*(4.0*K[4]*K[4] + 8.0*K[3]*K[3]) + K[5]*K[5]*(4.0*K[5]*K[5] + 8.0*(K[3]*K[3] + K[4]*K[4])));
    G[335] = 4.0*det*w[7][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[336] = det*w[7][0]*(2.0*(K[6]*K[6]*(K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4])) + 6.0*K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(6.0*K[4]*K[7] + 8.0*K[3]*K[6]) + K[5]*K[8]*(6.0*K[5]*K[8] + 8.0*(K[3]*K[6] + K[4]*K[7])));
    G[337] = 8.0*det*w[7][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[338] = det*w[7][0]*(2.0*(K[6]*K[6]*(K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4])) + 8.0*K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(12.0*K[3]*K[6] + 8.0*K[4]*K[7]) + K[5]*K[8]*(12.0*(K[3]*K[6] + K[4]*K[7]) + 8.0*K[5]*K[8]));
    G[339] = det*w[7][0]*w[7][0]*(K[4]*K[4]*(-2.0*K[4]*K[4]-4.0*K[3]*K[3]) + K[5]*K[5]*(-2.0*K[5]*K[5]-4.0*(K[3]*K[3] + K[4]*K[4]))-2.0*K[3]*K[3]*K[3]*K[3]);
    G[340] = -2.0*det*w[7][0]*w[7][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[341] = -4.0*det*w[7][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[342] = -4.0*det*w[7][0]*(K[3]*K[3]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]) + K[4]*K[4]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]) + K[5]*K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]));
    G[343] = det*w[7][0]*(K[4]*K[4]*(-2.0*K[4]*K[4]-4.0*K[3]*K[3]) + K[5]*K[5]*(-2.0*K[5]*K[5]-4.0*(K[3]*K[3] + K[4]*K[4]))-2.0*K[3]*K[3]*K[3]*K[3]);
    G[344] = -4.0*det*w[7][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[345] = -2.0*det*w[7][0]*(K[6]*K[6]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]));
    G[346] = -2.0*det*w[7][0]*w[7][0]*(K[6]*K[6]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]));
    G[347] = -2.0*det*w[7][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[348] = 4.0*det*w[7][0]*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[349] = det*w[7][0]*(2.0*K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(2.0*K[4]*K[7] + 4.0*K[3]*K[6]) + K[5]*K[8]*(2.0*K[5]*K[8] + 4.0*(K[3]*K[6] + K[4]*K[7])));
    G[350] = 2.0*det*w[7][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[351] = det*w[7][0]*(2.0*(K[6]*K[6]*(K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4])) + 4.0*(K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(K[3]*K[6] + K[4]*K[7]) + K[5]*K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[352] = 4.0*det*w[7][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[353] = det*w[7][0]*w[7][0]*(K[4]*K[7]*(-2.0*K[4]*K[7]-4.0*K[3]*K[6]) + K[5]*K[8]*(-2.0*K[5]*K[8]-4.0*(K[3]*K[6] + K[4]*K[7]))-2.0*K[3]*K[3]*K[6]*K[6]);
    G[354] = det*w[7][0]*(K[4]*K[7]*(-4.0*K[4]*K[7]-8.0*K[3]*K[6]) + K[5]*K[8]*(-4.0*K[5]*K[8]-8.0*(K[3]*K[6] + K[4]*K[7]))-4.0*K[3]*K[3]*K[6]*K[6]);
    G[355] = -2.0*det*w[7][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[356] = -2.0*det*w[7][0]*w[7][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[357] = det*w[7][0]*(K[4]*K[7]*(-2.0*K[4]*K[7]-4.0*K[3]*K[6]) + K[5]*K[8]*(-2.0*K[5]*K[8]-4.0*(K[3]*K[6] + K[4]*K[7]))-2.0*K[3]*K[3]*K[6]*K[6]);
    G[358] = 2.0*det*w[7][0]*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[359] = 2.0*det*w[7][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[360] = -4.0*det*w[7][0]*w[7][0]*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[361] = -4.0*det*w[7][0]*w[7][0]*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[362] = -4.0*det*w[7][0]*w[7][0]*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[363] = det*w[7][0]*(-2.0*(K[6]*K[6]*(K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4]))-4.0*(K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(K[3]*K[6] + K[4]*K[7]) + K[5]*K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[364] = det*w[7][0]*w[7][0]*(-2.0*(K[6]*K[6]*(K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4]))-4.0*(K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(K[3]*K[6] + K[4]*K[7]) + K[5]*K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[365] = -4.0*det*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[366] = -4.0*det*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[367] = det*(K[4]*K[4]*(-2.0*K[4]*K[4]-4.0*K[3]*K[3]) + K[5]*K[5]*(-2.0*K[5]*K[5]-4.0*(K[3]*K[3] + K[4]*K[4]))-2.0*K[3]*K[3]*K[3]*K[3]);
    G[368] = -4.0*det*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[369] = det*(K[4]*K[7]*(-2.0*K[4]*K[7]-4.0*K[3]*K[6]) + K[5]*K[8]*(-2.0*K[5]*K[8]-4.0*(K[3]*K[6] + K[4]*K[7]))-2.0*K[3]*K[3]*K[6]*K[6]);
    G[370] = -2.0*det*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[371] = -2.0*det*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[372] = det*(-2.0*(K[6]*K[6]*(K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4]))-4.0*(K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(K[3]*K[6] + K[4]*K[7]) + K[5]*K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[373] = -2.0*det*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[374] = -2.0*det*w[5][0]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]);
    G[375] = -2.0*det*w[7][0]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]);
    G[376] = 2.0*det*w[7][0]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]);
    G[377] = 2.0*det*w[5][0]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]);
    G[378] = -2.0*det*w[5][0]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8]);
    G[379] = -2.0*det*w[7][0]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8]);
    G[380] = 2.0*det*w[7][0]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8]);
    G[381] = 2.0*det*w[5][0]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8]);
    G[382] = det*w[5][0]*w[5][0]*(K[6]*K[6]*K[6]*K[6] + K[7]*K[7]*(2.0*K[6]*K[6] + K[7]*K[7]) + K[8]*K[8]*(2.0*(K[6]*K[6] + K[7]*K[7]) + K[8]*K[8]));
    G[383] = det*w[5][0]*w[5][0]*(2.0*K[6]*K[6]*K[6]*K[6] + K[7]*K[7]*(2.0*K[7]*K[7] + 4.0*K[6]*K[6]) + K[8]*K[8]*(2.0*K[8]*K[8] + 4.0*(K[6]*K[6] + K[7]*K[7])));
    G[384] = det*w[7][0]*w[7][0]*(K[6]*K[6]*K[6]*K[6] + K[7]*K[7]*(2.0*K[6]*K[6] + K[7]*K[7]) + K[8]*K[8]*(2.0*(K[6]*K[6] + K[7]*K[7]) + K[8]*K[8]));
    G[385] = det*w[7][0]*w[7][0]*(2.0*K[6]*K[6]*K[6]*K[6] + K[7]*K[7]*(2.0*K[7]*K[7] + 4.0*K[6]*K[6]) + K[8]*K[8]*(2.0*K[8]*K[8] + 4.0*(K[6]*K[6] + K[7]*K[7])));
    G[386] = det*(K[6]*K[6]*K[6]*K[6] + K[7]*K[7]*(2.0*K[6]*K[6] + K[7]*K[7]) + K[8]*K[8]*(2.0*(K[6]*K[6] + K[7]*K[7]) + K[8]*K[8]));
    G[387] = det*w[5][0]*(K[6]*K[6]*(12.0*K[0]*K[3] + 4.0*(K[1]*K[4] + K[2]*K[5])) + K[7]*(8.0*K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(12.0*K[1]*K[4] + 4.0*(K[0]*K[3] + K[2]*K[5]))) + K[8]*(8.0*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4])) + K[8]*(12.0*K[2]*K[5] + 4.0*(K[0]*K[3] + K[1]*K[4]))));
    G[388] = det*w[5][0]*(4.0*(K[6]*K[6]*(K[1]*K[4] + K[2]*K[5]) + K[7]*(K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(K[0]*K[3] + K[2]*K[5])) + K[8]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 8.0*(K[0]*K[3]*K[6]*K[6] + K[1]*K[4]*K[7]*K[7] + K[2]*K[5]*K[8]*K[8]));
    G[389] = 6.0*det*w[5][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[390] = 8.0*det*w[5][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[391] = 6.0*det*w[5][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[392] = 8.0*det*w[5][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[393] = det*w[5][0]*(2.0*K[6]*K[6]*K[6]*K[6] + K[7]*K[7]*(2.0*K[7]*K[7] + 4.0*K[6]*K[6]) + K[8]*K[8]*(2.0*K[8]*K[8] + 4.0*(K[6]*K[6] + K[7]*K[7])));
    G[394] = det*w[5][0]*(4.0*K[6]*K[6]*K[6]*K[6] + K[7]*K[7]*(4.0*K[7]*K[7] + 8.0*K[6]*K[6]) + K[8]*K[8]*(4.0*K[8]*K[8] + 8.0*(K[6]*K[6] + K[7]*K[7])));
    G[395] = -4.0*det*w[5][0]*(K[6]*K[6]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]) + K[7]*K[7]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]) + K[8]*K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]));
    G[396] = -4.0*det*w[5][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[397] = -4.0*det*w[5][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[398] = det*w[5][0]*(K[7]*K[7]*(-2.0*K[7]*K[7]-4.0*K[6]*K[6]) + K[8]*K[8]*(-2.0*K[8]*K[8]-4.0*(K[6]*K[6] + K[7]*K[7]))-2.0*K[6]*K[6]*K[6]*K[6]);
    G[399] = det*w[5][0]*w[5][0]*(K[7]*K[7]*(-2.0*K[7]*K[7]-4.0*K[6]*K[6]) + K[8]*K[8]*(-2.0*K[8]*K[8]-4.0*(K[6]*K[6] + K[7]*K[7]))-2.0*K[6]*K[6]*K[6]*K[6]);
    G[400] = 4.0*det*w[5][0]*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[401] = -4.0*det*w[5][0]*w[5][0]*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[402] = -4.0*det*w[5][0]*w[5][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[403] = -4.0*det*w[5][0]*w[5][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[404] = det*w[7][0]*(K[6]*K[6]*(12.0*K[0]*K[3] + 4.0*(K[1]*K[4] + K[2]*K[5])) + K[7]*(8.0*K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(12.0*K[1]*K[4] + 4.0*(K[0]*K[3] + K[2]*K[5]))) + K[8]*(8.0*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4])) + K[8]*(12.0*K[2]*K[5] + 4.0*(K[0]*K[3] + K[1]*K[4]))));
    G[405] = det*w[7][0]*(4.0*(K[6]*K[6]*(K[1]*K[4] + K[2]*K[5]) + K[7]*(K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(K[0]*K[3] + K[2]*K[5])) + K[8]*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4]) + K[8]*(K[0]*K[3] + K[1]*K[4]))) + 8.0*(K[0]*K[3]*K[6]*K[6] + K[1]*K[4]*K[7]*K[7] + K[2]*K[5]*K[8]*K[8]));
    G[406] = 6.0*det*w[7][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[407] = 8.0*det*w[7][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[408] = 6.0*det*w[7][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[409] = 8.0*det*w[7][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[410] = det*w[7][0]*(2.0*K[6]*K[6]*K[6]*K[6] + K[7]*K[7]*(2.0*K[7]*K[7] + 4.0*K[6]*K[6]) + K[8]*K[8]*(2.0*K[8]*K[8] + 4.0*(K[6]*K[6] + K[7]*K[7])));
    G[411] = det*w[7][0]*(4.0*K[6]*K[6]*K[6]*K[6] + K[7]*K[7]*(4.0*K[7]*K[7] + 8.0*K[6]*K[6]) + K[8]*K[8]*(4.0*K[8]*K[8] + 8.0*(K[6]*K[6] + K[7]*K[7])));
    G[412] = -4.0*det*w[7][0]*(K[6]*K[6]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]) + K[7]*K[7]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]) + K[8]*K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]));
    G[413] = -4.0*det*w[7][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[414] = -4.0*det*w[7][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[415] = det*w[7][0]*(K[7]*K[7]*(-2.0*K[7]*K[7]-4.0*K[6]*K[6]) + K[8]*K[8]*(-2.0*K[8]*K[8]-4.0*(K[6]*K[6] + K[7]*K[7]))-2.0*K[6]*K[6]*K[6]*K[6]);
    G[416] = det*w[7][0]*w[7][0]*(K[7]*K[7]*(-2.0*K[7]*K[7]-4.0*K[6]*K[6]) + K[8]*K[8]*(-2.0*K[8]*K[8]-4.0*(K[6]*K[6] + K[7]*K[7]))-2.0*K[6]*K[6]*K[6]*K[6]);
    G[417] = 4.0*det*w[7][0]*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[418] = -4.0*det*w[7][0]*w[7][0]*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[419] = -4.0*det*w[7][0]*w[7][0]*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[420] = -4.0*det*w[7][0]*w[7][0]*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[421] = -4.0*det*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[422] = -4.0*det*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[423] = -4.0*det*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[424] = det*(K[7]*K[7]*(-2.0*K[7]*K[7]-4.0*K[6]*K[6]) + K[8]*K[8]*(-2.0*K[8]*K[8]-4.0*(K[6]*K[6] + K[7]*K[7]))-2.0*K[6]*K[6]*K[6]*K[6]);
    G[425] = -2.0*det*w[5][0]*(K[6]*K[6] + K[7]*K[7] + K[8]*K[8]);
    G[426] = -2.0*det*w[7][0]*(K[6]*K[6] + K[7]*K[7] + K[8]*K[8]);
    G[427] = 2.0*det*w[7][0]*(K[6]*K[6] + K[7]*K[7] + K[8]*K[8]);
    G[428] = 2.0*det*w[5][0]*(K[6]*K[6] + K[7]*K[7] + K[8]*K[8]);
    G[429] = 4.0*det*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[430] = 4.0*det*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[431] = det*(2.0*K[0]*K[0]*K[0]*K[0] + K[1]*K[1]*(2.0*K[1]*K[1] + 4.0*K[0]*K[0]) + K[2]*K[2]*(2.0*K[2]*K[2] + 4.0*(K[0]*K[0] + K[1]*K[1])));
    G[432] = det*(2.0*(K[3]*K[3]*(K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1])) + 6.0*K[0]*K[0]*K[3]*K[3] + K[1]*K[4]*(6.0*K[1]*K[4] + 8.0*K[0]*K[3]) + K[2]*K[5]*(6.0*K[2]*K[5] + 8.0*(K[0]*K[3] + K[1]*K[4])));
    G[433] = det*(K[0]*K[0]*(12.0*K[3]*K[6] + 4.0*(K[4]*K[7] + K[5]*K[8])) + K[1]*(8.0*K[0]*(K[3]*K[7] + K[4]*K[6]) + K[1]*(12.0*K[4]*K[7] + 4.0*(K[3]*K[6] + K[5]*K[8]))) + K[2]*(8.0*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(12.0*K[5]*K[8] + 4.0*(K[3]*K[6] + K[4]*K[7]))));
    G[434] = 6.0*det*(K[0]*K[0]*K[0]*K[3] + K[1]*(K[0]*K[1]*K[3] + K[4]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[3] + K[1]*K[4]) + K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[435] = det*(K[0]*K[0]*(2.0*(K[4]*K[7] + K[5]*K[8]) + 6.0*K[3]*K[6]) + K[1]*(4.0*K[0]*(K[3]*K[7] + K[4]*K[6]) + K[1]*(2.0*(K[3]*K[6] + K[5]*K[8]) + 6.0*K[4]*K[7])) + K[2]*(4.0*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(2.0*(K[3]*K[6] + K[4]*K[7]) + 6.0*K[5]*K[8])));
    G[436] = det*(2.0*(K[6]*K[6]*(K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1])) + 6.0*K[0]*K[0]*K[6]*K[6] + K[1]*K[7]*(6.0*K[1]*K[7] + 8.0*K[0]*K[6]) + K[2]*K[8]*(6.0*K[2]*K[8] + 8.0*(K[0]*K[6] + K[1]*K[7])));
    G[437] = 6.0*det*(K[0]*K[0]*K[0]*K[6] + K[1]*(K[0]*K[1]*K[6] + K[7]*(K[0]*K[0] + K[1]*K[1])) + K[2]*(K[2]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2])));
    G[438] = -2.0*det*(K[3]*K[3]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[4]*K[4]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[5]*K[5]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[439] = -4.0*det*(K[3]*K[6]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[4]*K[7]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[5]*K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[440] = -2.0*det*(K[6]*K[6]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[7]*K[7]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[8]*K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[441] = -2.0*det*(K[3]*K[6]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[4]*K[7]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]) + K[5]*K[8]*(K[0]*K[0] + K[1]*K[1] + K[2]*K[2]));
    G[442] = 4.0*det*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[443] = det*(K[3]*K[3]*(12.0*K[0]*K[6] + 4.0*(K[1]*K[7] + K[2]*K[8])) + K[4]*(8.0*K[3]*(K[0]*K[7] + K[1]*K[6]) + K[4]*(12.0*K[1]*K[7] + 4.0*(K[0]*K[6] + K[2]*K[8]))) + K[5]*(8.0*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(12.0*K[2]*K[8] + 4.0*(K[0]*K[6] + K[1]*K[7]))));
    G[444] = 6.0*det*(K[0]*K[3]*K[3]*K[3] + K[4]*(K[1]*K[3]*K[3] + K[4]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[3] + K[4]*K[4]) + K[5]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[445] = det*(K[3]*K[3]*(2.0*(K[1]*K[7] + K[2]*K[8]) + 6.0*K[0]*K[6]) + K[4]*(4.0*K[3]*(K[0]*K[7] + K[1]*K[6]) + K[4]*(2.0*(K[0]*K[6] + K[2]*K[8]) + 6.0*K[1]*K[7])) + K[5]*(4.0*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(2.0*(K[0]*K[6] + K[1]*K[7]) + 6.0*K[2]*K[8])));
    G[446] = det*(K[6]*K[6]*(12.0*K[0]*K[3] + 4.0*(K[1]*K[4] + K[2]*K[5])) + K[7]*(8.0*K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(12.0*K[1]*K[4] + 4.0*(K[0]*K[3] + K[2]*K[5]))) + K[8]*(8.0*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4])) + K[8]*(12.0*K[2]*K[5] + 4.0*(K[0]*K[3] + K[1]*K[4]))));
    G[447] = det*(K[1]*K[4]*(-16.0*K[0]*K[3]-8.0*K[1]*K[4]) + K[2]*K[5]*(-16.0*(K[0]*K[3] + K[1]*K[4])-8.0*K[2]*K[5])-8.0*K[0]*K[0]*K[3]*K[3]);
    G[448] = -8.0*det*(K[0]*K[0]*K[3]*K[6] + K[1]*(K[0]*K[4]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[2]*(K[5]*(K[0]*K[6] + K[1]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[449] = -8.0*det*(K[0]*K[3]*K[3]*K[6] + K[4]*(K[1]*K[3]*K[6] + K[7]*(K[0]*K[3] + K[1]*K[4])) + K[5]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5])));
    G[450] = -4.0*det*(K[6]*K[6]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]) + K[7]*K[7]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]) + K[8]*K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]));
    G[451] = det*(K[1]*K[4]*(-4.0*K[1]*K[4]-8.0*K[0]*K[3]) + K[2]*K[5]*(-4.0*K[2]*K[5]-8.0*(K[0]*K[3] + K[1]*K[4]))-4.0*K[0]*K[0]*K[3]*K[3]);
    G[452] = 4.0*det*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[453] = det*(K[6]*K[6]*(2.0*(K[1]*K[4] + K[2]*K[5]) + 6.0*K[0]*K[3]) + K[7]*(4.0*K[6]*(K[0]*K[4] + K[1]*K[3]) + K[7]*(2.0*(K[0]*K[3] + K[2]*K[5]) + 6.0*K[1]*K[4])) + K[8]*(4.0*(K[6]*(K[0]*K[5] + K[2]*K[3]) + K[7]*(K[1]*K[5] + K[2]*K[4])) + K[8]*(2.0*(K[0]*K[3] + K[1]*K[4]) + 6.0*K[2]*K[5])));
    G[454] = 6.0*det*(K[0]*K[6]*K[6]*K[6] + K[7]*(K[1]*K[6]*K[6] + K[7]*(K[0]*K[6] + K[1]*K[7])) + K[8]*(K[2]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[455] = det*(K[1]*K[7]*(-16.0*K[0]*K[6]-8.0*K[1]*K[7]) + K[2]*K[8]*(-16.0*(K[0]*K[6] + K[1]*K[7])-8.0*K[2]*K[8])-8.0*K[0]*K[0]*K[6]*K[6]);
    G[456] = -4.0*det*(K[3]*K[3]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]) + K[4]*K[4]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]) + K[5]*K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]));
    G[457] = -8.0*det*(K[0]*K[3]*K[6]*K[6] + K[7]*(K[1]*K[4]*K[7] + K[6]*(K[0]*K[4] + K[1]*K[3])) + K[8]*(K[2]*(K[3]*K[6] + K[4]*K[7]) + K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8])));
    G[458] = det*(K[1]*K[7]*(-4.0*K[1]*K[7]-8.0*K[0]*K[6]) + K[2]*K[8]*(-4.0*K[2]*K[8]-8.0*(K[0]*K[6] + K[1]*K[7]))-4.0*K[0]*K[0]*K[6]*K[6]);
    G[459] = -2.0*det*(K[6]*K[6]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]) + K[7]*K[7]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]) + K[8]*K[8]*(K[0]*K[3] + K[1]*K[4] + K[2]*K[5]));
    G[460] = -2.0*det*(K[3]*K[3]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]) + K[4]*K[4]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]) + K[5]*K[5]*(K[0]*K[6] + K[1]*K[7] + K[2]*K[8]));
    G[461] = 4.0*det*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[462] = det*(2.0*K[3]*K[3]*K[3]*K[3] + K[4]*K[4]*(2.0*K[4]*K[4] + 4.0*K[3]*K[3]) + K[5]*K[5]*(2.0*K[5]*K[5] + 4.0*(K[3]*K[3] + K[4]*K[4])));
    G[463] = det*(2.0*(K[6]*K[6]*(K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4])) + 6.0*K[3]*K[3]*K[6]*K[6] + K[4]*K[7]*(6.0*K[4]*K[7] + 8.0*K[3]*K[6]) + K[5]*K[8]*(6.0*K[5]*K[8] + 8.0*(K[3]*K[6] + K[4]*K[7])));
    G[464] = 6.0*det*(K[3]*K[3]*K[3]*K[6] + K[4]*(K[3]*K[4]*K[6] + K[7]*(K[3]*K[3] + K[4]*K[4])) + K[5]*(K[5]*(K[3]*K[6] + K[4]*K[7]) + K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5])));
    G[465] = -2.0*det*(K[6]*K[6]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]) + K[7]*K[7]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]) + K[8]*K[8]*(K[3]*K[3] + K[4]*K[4] + K[5]*K[5]));
    G[466] = 4.0*det*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[467] = 6.0*det*(K[3]*K[6]*K[6]*K[6] + K[7]*(K[4]*K[6]*K[6] + K[7]*(K[3]*K[6] + K[4]*K[7])) + K[8]*(K[5]*(K[6]*K[6] + K[7]*K[7]) + K[8]*(K[3]*K[6] + K[4]*K[7] + K[5]*K[8])));
    G[468] = det*(K[4]*K[7]*(-16.0*K[3]*K[6]-8.0*K[4]*K[7]) + K[5]*K[8]*(-16.0*(K[3]*K[6] + K[4]*K[7])-8.0*K[5]*K[8])-8.0*K[3]*K[3]*K[6]*K[6]);
    G[469] = det*(K[4]*K[7]*(-4.0*K[4]*K[7]-8.0*K[3]*K[6]) + K[5]*K[8]*(-4.0*K[5]*K[8]-8.0*(K[3]*K[6] + K[4]*K[7]))-4.0*K[3]*K[3]*K[6]*K[6]);
    G[470] = det*(2.0*K[6]*K[6]*K[6]*K[6] + K[7]*K[7]*(2.0*K[7]*K[7] + 4.0*K[6]*K[6]) + K[8]*K[8]*(2.0*K[8]*K[8] + 4.0*(K[6]*K[6] + K[7]*K[7])));
    G[471] = det*w[5][0]*w[5][0];
    G[472] = 2.0*det*w[5][0]*w[7][0];
    G[473] = -2.0*det*w[5][0]*w[7][0];
    G[474] = -2.0*det*w[5][0]*w[5][0];
    G[475] = det*w[7][0]*w[7][0];
    G[476] = -2.0*det*w[7][0]*w[7][0];
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 1022125
    for (unsigned int ip = 0; ip < 125; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      double F10 = 0.0;
      double F11 = 0.0;
      double F12 = 0.0;
      double F13 = 0.0;
      double F14 = 0.0;
      double F15 = 0.0;
      double F16 = 0.0;
      double F17 = 0.0;
      double F18 = 0.0;
      double F19 = 0.0;
      double F20 = 0.0;
      double F21 = 0.0;
      double F22 = 0.0;
      double F23 = 0.0;
      double F24 = 0.0;
      double F25 = 0.0;
      double F26 = 0.0;
      double F27 = 0.0;
      double F28 = 0.0;
      double F29 = 0.0;
      double F30 = 0.0;
      double F31 = 0.0;
      double F32 = 0.0;
      double F33 = 0.0;
      
      // Total number of operations to compute function values = 108
      for (unsigned int r = 0; r < 2; r++)
      {
        F2 += FE0_D001[ip][r]*w[2][nzc2[r]];
        F3 += FE0_D001[ip][r]*w[2][nzc1[r]];
        F4 += FE0_D001[ip][r]*w[2][nzc0[r]];
        F5 += FE0_D001[ip][r]*w[3][nzc2[r]];
        F6 += FE0_D001[ip][r]*w[3][nzc1[r]];
        F7 += FE0_D001[ip][r]*w[3][nzc0[r]];
        F11 += FE0_D001[ip][r]*w[10][nzc2[r]];
        F12 += FE0_D001[ip][r]*w[10][nzc1[r]];
        F13 += FE0_D001[ip][r]*w[10][nzc0[r]];
        F14 += FE0_D001[ip][r]*w[8][nzc2[r]];
        F15 += FE0_D001[ip][r]*w[8][nzc1[r]];
        F16 += FE0_D001[ip][r]*w[8][nzc0[r]];
        F18 += FE0_D001[ip][r]*w[4][nzc2[r]];
        F19 += FE0_D001[ip][r]*w[4][nzc1[r]];
        F20 += FE0_D001[ip][r]*w[4][nzc0[r]];
        F21 += FE0_D001[ip][r]*w[0][nzc2[r]];
        F22 += FE0_D001[ip][r]*w[0][nzc1[r]];
        F23 += FE0_D001[ip][r]*w[0][nzc0[r]];
        F24 += FE0_D001[ip][r]*w[9][nzc2[r]];
        F25 += FE0_D001[ip][r]*w[9][nzc1[r]];
        F26 += FE0_D001[ip][r]*w[9][nzc0[r]];
        F28 += FE0_D001[ip][r]*w[6][nzc2[r]];
        F29 += FE0_D001[ip][r]*w[6][nzc1[r]];
        F30 += FE0_D001[ip][r]*w[6][nzc0[r]];
        F31 += FE0_D001[ip][r]*w[1][nzc2[r]];
        F32 += FE0_D001[ip][r]*w[1][nzc1[r]];
        F33 += FE0_D001[ip][r]*w[1][nzc0[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 56
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0[ip][r]*w[0][r];
        F1 += FE0[ip][r]*w[1][r];
        F8 += FE0[ip][r]*w[3][r];
        F9 += FE0[ip][r]*w[8][r];
        F10 += FE0[ip][r]*w[9][r];
        F17 += FE0[ip][r]*w[4][r];
        F27 += FE0[ip][r]*w[6][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 8012
      double I[1];
      // Number of operations: 8012
      I[0] = W125[ip]*(F5*(std::exp(F0)*(F11*G[252] + F12*G[256] + F13*G[260] + F2*G[255] + F3*G[259] + F4*G[263]) + std::exp(F1)*(F11*G[253] + F12*G[257] + F13*G[261] + F2*G[254] + F3*G[258] + F4*G[262])) + F5*F5*(F11*F11*G[18] + F12*(F11*G[19] + F12*G[21]) + F13*(F11*G[20] + F12*G[22] + F13*G[23]) + F2*(F11*G[158] + F12*G[241] + F13*G[247] + F2*G[18]) + F3*(F11*G[241] + F12*G[161] + F13*G[370] + F2*G[19] + F3*G[21]) + F4*(F11*G[247] + F12*G[370] + F13*G[163] + F2*G[20] + F3*G[22] + F4*G[23])) + F6*(F5*(F11*F11*G[19] + F12*(F11*G[40] + F12*G[42]) + F13*(F11*G[41] + F12*G[43] + F13*G[44]) + F2*(F11*G[159] + F12*G[242] + F13*G[243] + F2*G[19]) + F3*(F11*G[242] + F12*G[365] + F13*G[245] + F2*G[40] + F3*G[42]) + F4*(F11*G[243] + F12*G[245] + F13*G[421] + F2*G[41] + F3*G[43] + F4*G[44])) + F6*(F11*F11*G[21] + F12*(F11*G[42] + F12*G[274]) + F13*(F11*G[60] + F12*G[275] + F13*G[276]) + F2*(F11*G[161] + F12*G[244] + F13*G[249] + F2*G[21]) + F3*(F11*G[244] + F12*G[367] + F13*G[371] + F2*G[42] + F3*G[274]) + F4*(F11*G[249] + F12*G[371] + F13*G[369] + F2*G[60] + F3*G[275] + F4*G[276])) + std::exp(F0)*(F11*G[256] + F12*G[374] + F13*G[378] + F2*G[259] + F3*G[377] + F4*G[381]) + std::exp(F1)*(F11*G[257] + F12*G[375] + F13*G[379] + F2*G[258] + F3*G[376] + F4*G[380])) + F7*(F5*(F11*F11*G[20] + F12*(F11*G[41] + F12*G[60]) + F13*(F11*G[59] + F12*G[61] + F13*G[62]) + F2*(F11*G[160] + F12*G[243] + F13*G[248] + F2*G[20]) + F3*(F11*G[243] + F12*G[366] + F13*G[250] + F2*G[41] + F3*G[60]) + F4*(F11*G[248] + F12*G[250] + F13*G[422] + F2*G[59] + F3*G[61] + F4*G[62])) + F6*(F11*F11*G[22] + F12*(F11*G[43] + F12*G[275]) + F13*(F11*G[61] + F12*G[287] + F13*G[288]) + F2*(F11*G[162] + F12*G[245] + F13*G[250] + F2*G[22]) + F3*(F11*G[245] + F12*G[368] + F13*G[372] + F2*G[43] + F3*G[275]) + F4*(F11*G[250] + F12*G[372] + F13*G[423] + F2*G[61] + F3*G[287] + F4*G[288])) + F7*(F11*F11*G[23] + F12*(F11*G[44] + F12*G[276]) + F13*(F11*G[62] + F12*G[288] + F13*G[386]) + F2*(F11*G[163] + F12*G[246] + F13*G[251] + F2*G[23]) + F3*(F11*G[246] + F12*G[369] + F13*G[373] + F2*G[44] + F3*G[276]) + F4*(F11*G[251] + F12*G[373] + F13*G[424] + F2*G[62] + F3*G[288] + F4*G[386])) + std::exp(F0)*(F11*G[260] + F12*G[378] + F13*G[425] + F2*G[263] + F3*G[381] + F4*G[428]) + std::exp(F1)*(F11*G[261] + F12*G[379] + F13*G[426] + F2*G[262] + F3*G[380] + F4*G[427])) + G[472]*std::exp(F0)*std::exp(F1) + std::exp(F0)*std::exp(F0)*(G[471] + F17*(F21*(F2*F2*(F18*G[3] + F19*G[1] + F20*G[2]) + F3*(F2*(F18*G[26] + F19*G[24] + F20*G[25]) + F3*(F18*G[6] + F19*G[27] + F20*G[47])) + F4*(F2*(F18*G[46] + F19*G[25] + F20*G[45]) + F3*(F18*G[277] + F19*G[28] + F20*G[48]) + F4*(F18*G[8] + F19*G[30] + F20*G[50]))) + F21*F21*(F17*(F2*F2*G[0] + F21*(F2*G[63] + F21*G[18]) + F3*(F2*G[1] + F21*G[117] + F3*G[4]) + F4*(F2*G[2] + F21*G[134] + F3*G[5] + F4*G[7])) + F18*(F2*G[66] + F21*G[431] + F3*G[67] + F4*G[68]) + F19*(F2*G[67] + F21*G[19] + F3*G[97] + F4*G[118]) + F20*(F2*G[68] + F21*G[20] + F3*G[118] + F4*G[121])) + F22*(F2*F2*(F18*G[1] + F19*G[6] + F20*G[5]) + F21*(F17*(F2*F2*G[1] + F21*(F2*G[64] + F21*G[429]) + F3*(F2*G[24] + F21*G[69] + F3*G[27]) + F4*(F2*G[25] + F21*G[289] + F3*G[28] + F4*G[30])) + F18*(F2*G[71] + F21*G[434] + F3*G[72] + F4*G[73]) + F19*(F2*G[72] + F21*G[432] + F3*G[292] + F4*G[102]) + F20*(F2*G[73] + F21*G[435] + F3*G[102] + F4*G[388])) + F22*(F17*(F2*F2*G[4] + F21*(F2*G[69] + F21*G[432]) + F22*(F2*G[95] + F21*G[442] + F22*G[274]) + F3*(F2*G[27] + F21*G[290] + F22*G[294] + F3*G[264]) + F4*(F2*G[47] + F21*G[96] + F22*G[321] + F3*G[265] + F4*G[267])) + F18*(F2*G[97] + F21*G[432] + F22*G[42] + F3*G[98] + F4*G[99]) + F19*(F2*G[98] + F21*G[444] + F22*G[462] + F3*G[296] + F4*G[297]) + F20*(F2*G[99] + F21*G[445] + F22*G[275] + F3*G[297] + F4*G[313])) + F3*(F2*(F18*G[24] + F19*G[29] + F20*G[28]) + F3*(F18*G[27] + F19*G[266] + F20*G[265])) + F4*(F2*(F18*G[25] + F19*G[49] + F20*G[48]) + F3*(F18*G[28] + F19*G[279] + F20*G[278]) + F4*(F18*G[30] + F19*G[268] + F20*G[280]))) + F23*(F17*(F21*(F2*F2*G[2] + F21*(F2*G[65] + F21*G[430]) + F3*(F2*G[25] + F21*G[289] + F3*G[47]) + F4*(F2*G[45] + F21*G[74] + F3*G[48] + F4*G[50])) + F22*(F2*F2*G[5] + F21*(F2*G[70] + F21*G[433]) + F22*(F2*G[96] + F21*G[443] + F22*G[461]) + F3*(F2*G[28] + F21*G[291] + F22*G[295] + F3*G[265]) + F4*(F2*G[48] + F21*G[387] + F22*G[298] + F3*G[278] + F4*G[280])) + F23*(F2*F2*G[7] + F21*(F2*G[74] + F21*G[436]) + F22*(F2*G[100] + F21*G[446] + F22*G[463]) + F23*(F2*G[120] + F21*G[452] + F22*G[466] + F23*G[386]) + F3*(F2*G[30] + F21*G[100] + F22*G[298] + F23*G[312] + F3*G[267]) + F4*(F2*G[50] + F21*G[389] + F22*G[391] + F23*G[393] + F3*G[280] + F4*G[382]))) + F18*(F2*F2*G[2] + F21*(F2*G[75] + F21*G[437]) + F22*(F2*G[101] + F21*G[433] + F22*G[445]) + F23*(F2*G[121] + F21*G[436] + F22*G[453] + F23*G[62]) + F3*(F2*G[25] + F21*G[73] + F22*G[102] + F23*G[122] + F3*G[47]) + F4*(F2*G[45] + F21*G[76] + F22*G[103] + F23*G[123] + F3*G[48] + F4*G[50])) + F19*(F2*F2*G[5] + F21*(F2*G[73] + F21*G[435]) + F22*(F2*G[102] + F21*G[443] + F22*G[464]) + F23*(F2*G[122] + F21*G[453] + F22*G[463] + F23*G[288]) + F3*(F2*G[28] + F21*G[293] + F22*G[299] + F23*G[313] + F3*G[265]) + F4*(F2*G[48] + F21*G[103] + F22*G[300] + F23*G[314] + F3*G[278] + F4*G[280])) + F20*(F2*F2*G[8] + F21*(F2*G[76] + F21*G[436]) + F22*(F2*G[103] + F21*G[446] + F22*G[463]) + F23*(F2*G[123] + F21*G[454] + F22*G[467] + F23*G[470]) + F3*(F2*G[31] + F21*G[103] + F22*G[300] + F23*G[314] + F3*G[268]) + F4*(F2*G[51] + F21*G[390] + F22*G[392] + F23*G[394] + F3*G[281] + F4*G[383])))) + F18*F18*(F2*F2*G[0] + F21*(F2*G[63] + F21*G[18]) + F22*(F2*G[117] + F21*G[19] + F22*G[21]) + F23*(F2*G[134] + F21*G[20] + F22*G[22] + F23*G[23]) + F3*(F2*G[1] + F21*G[117] + F22*G[92] + F23*G[320] + F3*G[4]) + F4*(F2*G[2] + F21*G[134] + F22*G[320] + F23*G[94] + F3*G[5] + F4*G[7])) + F19*(F18*(F2*F2*G[1] + F21*(F2*G[67] + F21*G[19]) + F22*(F2*G[97] + F21*G[40] + F22*G[42]) + F23*(F2*G[118] + F21*G[41] + F22*G[43] + F23*G[44]) + F3*(F2*G[24] + F21*G[97] + F22*G[98] + F23*G[99] + F3*G[27]) + F4*(F2*G[25] + F21*G[118] + F22*G[99] + F23*G[400] + F3*G[28] + F4*G[30])) + F19*(F2*F2*G[4] + F21*(F2*G[92] + F21*G[21]) + F22*(F2*G[95] + F21*G[42] + F22*G[274]) + F23*(F2*G[135] + F21*G[60] + F22*G[275] + F23*G[276]) + F3*(F2*G[27] + F21*G[95] + F22*G[294] + F23*G[321] + F3*G[264]) + F4*(F2*G[47] + F21*G[135] + F22*G[321] + F23*G[311] + F3*G[265] + F4*G[267]))) + F20*(F18*(F2*F2*G[2] + F21*(F2*G[68] + F21*G[20]) + F22*(F2*G[118] + F21*G[41] + F22*G[60]) + F23*(F2*G[121] + F21*G[59] + F22*G[61] + F23*G[62]) + F3*(F2*G[25] + F21*G[118] + F22*G[310] + F23*G[122] + F3*G[47]) + F4*(F2*G[45] + F21*G[121] + F22*G[122] + F23*G[123] + F3*G[48] + F4*G[50])) + F19*(F2*F2*G[5] + F21*(F2*G[93] + F21*G[22]) + F22*(F2*G[99] + F21*G[43] + F22*G[275]) + F23*(F2*G[122] + F21*G[61] + F22*G[287] + F23*G[288]) + F3*(F2*G[28] + F21*G[99] + F22*G[297] + F23*G[313] + F3*G[265]) + F4*(F2*G[48] + F21*G[122] + F22*G[313] + F23*G[314] + F3*G[278] + F4*G[280])) + F20*(F2*F2*G[7] + F21*(F2*G[94] + F21*G[23]) + F22*(F2*G[119] + F21*G[44] + F22*G[276]) + F23*(F2*G[120] + F21*G[62] + F22*G[288] + F23*G[386]) + F3*(F2*G[30] + F21*G[119] + F22*G[311] + F23*G[312] + F3*G[267]) + F4*(F2*G[50] + F21*G[120] + F22*G[312] + F23*G[393] + F3*G[280] + F4*G[382])))) + std::exp(F1)*std::exp(F1)*(G[475] + F27*(F31*(F2*F2*(F28*G[12] + F29*G[10] + F30*G[11]) + F3*(F2*(F28*G[34] + F29*G[32] + F30*G[33]) + F3*(F28*G[15] + F29*G[35] + F30*G[54])) + F4*(F2*(F28*G[53] + F29*G[33] + F30*G[52]) + F3*(F28*G[282] + F29*G[36] + F30*G[55]) + F4*(F28*G[17] + F29*G[38] + F30*G[57]))) + F31*F31*(F27*(F2*F2*G[9] + F3*(F2*G[10] + F3*G[13]) + F31*(F2*G[164] + F3*G[213] + F31*G[18]) + F4*(F2*G[11] + F3*G[14] + F31*G[229] + F4*G[16])) + F28*(F2*G[167] + F3*G[168] + F31*G[431] + F4*G[169]) + F29*(F2*G[168] + F3*G[195] + F31*G[19] + F4*G[214]) + F30*(F2*G[169] + F3*G[214] + F31*G[20] + F4*G[217])) + F32*(F2*F2*(F28*G[10] + F29*G[15] + F30*G[14]) + F3*(F2*(F28*G[32] + F29*G[37] + F30*G[36]) + F3*(F28*G[35] + F29*G[271] + F30*G[270])) + F31*(F27*(F2*F2*G[10] + F3*(F2*G[32] + F3*G[35]) + F31*(F2*G[165] + F3*G[170] + F31*G[429]) + F4*(F2*G[33] + F3*G[36] + F31*G[327] + F4*G[38])) + F28*(F2*G[172] + F3*G[173] + F31*G[434] + F4*G[174]) + F29*(F2*G[173] + F3*G[330] + F31*G[432] + F4*G[200]) + F30*(F2*G[174] + F3*G[200] + F31*G[435] + F4*G[405])) + F32*(F27*(F2*F2*G[13] + F3*(F2*G[35] + F3*G[269]) + F31*(F2*G[170] + F3*G[328] + F31*G[432]) + F32*(F2*G[193] + F3*G[332] + F31*G[442] + F32*G[274]) + F4*(F2*G[54] + F3*G[270] + F31*G[194] + F32*G[359] + F4*G[272])) + F28*(F2*G[195] + F3*G[196] + F31*G[432] + F32*G[42] + F4*G[197]) + F29*(F2*G[196] + F3*G[334] + F31*G[444] + F32*G[462] + F4*G[335]) + F30*(F2*G[197] + F3*G[335] + F31*G[445] + F32*G[275] + F4*G[351])) + F4*(F2*(F28*G[33] + F29*G[56] + F30*G[55]) + F3*(F28*G[36] + F29*G[284] + F30*G[283]) + F4*(F28*G[38] + F29*G[273] + F30*G[285]))) + F33*(F27*(F31*(F2*F2*G[11] + F3*(F2*G[33] + F3*G[54]) + F31*(F2*G[166] + F3*G[327] + F31*G[430]) + F4*(F2*G[52] + F3*G[55] + F31*G[175] + F4*G[57])) + F32*(F2*F2*G[14] + F3*(F2*G[36] + F3*G[270]) + F31*(F2*G[171] + F3*G[329] + F31*G[433]) + F32*(F2*G[194] + F3*G[333] + F31*G[443] + F32*G[461]) + F4*(F2*G[55] + F3*G[283] + F31*G[404] + F32*G[336] + F4*G[285])) + F33*(F2*F2*G[16] + F3*(F2*G[38] + F3*G[272]) + F31*(F2*G[175] + F3*G[198] + F31*G[436]) + F32*(F2*G[198] + F3*G[336] + F31*G[446] + F32*G[463]) + F33*(F2*G[216] + F3*G[350] + F31*G[452] + F32*G[466] + F33*G[386]) + F4*(F2*G[57] + F3*G[285] + F31*G[406] + F32*G[408] + F33*G[410] + F4*G[384]))) + F28*(F2*F2*G[11] + F3*(F2*G[33] + F3*G[54]) + F31*(F2*G[176] + F3*G[174] + F31*G[437]) + F32*(F2*G[199] + F3*G[200] + F31*G[433] + F32*G[445]) + F33*(F2*G[217] + F3*G[218] + F31*G[436] + F32*G[453] + F33*G[62]) + F4*(F2*G[52] + F3*G[55] + F31*G[177] + F32*G[201] + F33*G[219] + F4*G[57])) + F29*(F2*F2*G[14] + F3*(F2*G[36] + F3*G[270]) + F31*(F2*G[174] + F3*G[331] + F31*G[435]) + F32*(F2*G[200] + F3*G[337] + F31*G[443] + F32*G[464]) + F33*(F2*G[218] + F3*G[351] + F31*G[453] + F32*G[463] + F33*G[288]) + F4*(F2*G[55] + F3*G[283] + F31*G[201] + F32*G[338] + F33*G[352] + F4*G[285])) + F30*(F2*F2*G[17] + F3*(F2*G[39] + F3*G[273]) + F31*(F2*G[177] + F3*G[201] + F31*G[436]) + F32*(F2*G[201] + F3*G[338] + F31*G[446] + F32*G[463]) + F33*(F2*G[219] + F3*G[352] + F31*G[454] + F32*G[467] + F33*G[470]) + F4*(F2*G[58] + F3*G[286] + F31*G[407] + F32*G[409] + F33*G[411] + F4*G[385])))) + F28*F28*(F2*F2*G[9] + F3*(F2*G[10] + F3*G[13]) + F31*(F2*G[164] + F3*G[213] + F31*G[18]) + F32*(F2*G[213] + F3*G[190] + F31*G[19] + F32*G[21]) + F33*(F2*G[229] + F3*G[358] + F31*G[20] + F32*G[22] + F33*G[23]) + F4*(F2*G[11] + F3*G[14] + F31*G[229] + F32*G[358] + F33*G[192] + F4*G[16])) + F29*(F28*(F2*F2*G[10] + F3*(F2*G[32] + F3*G[35]) + F31*(F2*G[168] + F3*G[195] + F31*G[19]) + F32*(F2*G[195] + F3*G[196] + F31*G[40] + F32*G[42]) + F33*(F2*G[214] + F3*G[197] + F31*G[41] + F32*G[43] + F33*G[44]) + F4*(F2*G[33] + F3*G[36] + F31*G[214] + F32*G[197] + F33*G[417] + F4*G[38])) + F29*(F2*F2*G[13] + F3*(F2*G[35] + F3*G[269]) + F31*(F2*G[190] + F3*G[193] + F31*G[21]) + F32*(F2*G[193] + F3*G[332] + F31*G[42] + F32*G[274]) + F33*(F2*G[230] + F3*G[359] + F31*G[60] + F32*G[275] + F33*G[276]) + F4*(F2*G[54] + F3*G[270] + F31*G[230] + F32*G[359] + F33*G[349] + F4*G[272]))) + F30*(F28*(F2*F2*G[11] + F3*(F2*G[33] + F3*G[54]) + F31*(F2*G[169] + F3*G[214] + F31*G[20]) + F32*(F2*G[214] + F3*G[348] + F31*G[41] + F32*G[60]) + F33*(F2*G[217] + F3*G[218] + F31*G[59] + F32*G[61] + F33*G[62]) + F4*(F2*G[52] + F3*G[55] + F31*G[217] + F32*G[218] + F33*G[219] + F4*G[57])) + F29*(F2*F2*G[14] + F3*(F2*G[36] + F3*G[270]) + F31*(F2*G[191] + F3*G[197] + F31*G[22]) + F32*(F2*G[197] + F3*G[335] + F31*G[43] + F32*G[275]) + F33*(F2*G[218] + F3*G[351] + F31*G[61] + F32*G[287] + F33*G[288]) + F4*(F2*G[55] + F3*G[283] + F31*G[218] + F32*G[351] + F33*G[352] + F4*G[285])) + F30*(F2*F2*G[16] + F3*(F2*G[38] + F3*G[272]) + F31*(F2*G[192] + F3*G[215] + F31*G[23]) + F32*(F2*G[215] + F3*G[349] + F31*G[44] + F32*G[276]) + F33*(F2*G[216] + F3*G[350] + F31*G[62] + F32*G[288] + F33*G[386]) + F4*(F2*G[57] + F3*G[285] + F31*G[216] + F32*G[350] + F33*G[410] + F4*G[384])))) + std::exp(F10)*(F27*(std::exp(F1)*(F24*(F2*(F28*(F11*G[149] + F12*G[150] + F13*G[151] + F24*G[180]) + F29*(F11*G[150] + F12*G[152] + F13*G[153] + F24*G[187]) + F30*(F11*G[151] + F12*G[153] + F13*G[154] + F24*G[188])) + F3*(F28*(F11*G[150] + F12*G[152] + F13*G[153] + F24*G[187]) + F29*(F11*G[178] + F12*G[202] + F13*G[220] + F24*G[183]) + F30*(F11*G[179] + F12*G[203] + F13*G[221] + F24*G[189])) + F4*(F28*(F11*G[151] + F12*G[153] + F13*G[154] + F24*G[188]) + F29*(F11*G[179] + F12*G[203] + F13*G[221] + F24*G[189]) + F30*(F11*G[186] + F12*G[209] + F13*G[226] + F24*G[185]))) + F25*(F2*(F28*(F11*G[150] + F12*G[178] + F13*G[179] + F24*G[181] + F25*G[183]) + F29*(F11*G[152] + F12*G[202] + F13*G[203] + F24*G[204] + F25*G[206]) + F30*(F11*G[153] + F12*G[220] + F13*G[221] + F24*G[205] + F25*G[223])) + F3*(F28*(F11*G[152] + F12*G[202] + F13*G[203] + F24*G[204] + F25*G[206]) + F29*(F11*G[202] + F12*G[339] + F13*G[340] + F24*G[341] + F25*G[343]) + F30*(F11*G[203] + F12*G[340] + F13*G[353] + F24*G[207] + F25*G[347])) + F4*(F28*(F11*G[153] + F12*G[220] + F13*G[221] + F24*G[205] + F25*G[223]) + F29*(F11*G[203] + F12*G[340] + F13*G[353] + F24*G[207] + F25*G[347]) + F30*(F11*G[209] + F12*G[346] + F13*G[356] + F24*G[412] + F25*G[345]))) + F26*(F2*(F28*(F11*G[151] + F12*G[179] + F13*G[186] + F24*G[182] + F25*G[184] + F26*G[185]) + F29*(F11*G[153] + F12*G[203] + F13*G[209] + F24*G[205] + F25*G[207] + F26*G[208]) + F30*(F11*G[154] + F12*G[221] + F13*G[226] + F24*G[222] + F25*G[224] + F26*G[225])) + F3*(F28*(F11*G[153] + F12*G[203] + F13*G[209] + F24*G[205] + F25*G[207] + F26*G[208]) + F29*(F11*G[220] + F12*G[340] + F13*G[346] + F24*G[342] + F25*G[344] + F26*G[345]) + F30*(F11*G[221] + F12*G[353] + F13*G[356] + F24*G[224] + F25*G[354] + F26*G[355])) + F4*(F28*(F11*G[154] + F12*G[221] + F13*G[226] + F24*G[222] + F25*G[224] + F26*G[225]) + F29*(F11*G[221] + F12*G[353] + F13*G[356] + F24*G[224] + F25*G[354] + F26*G[355]) + F30*(F11*G[226] + F12*G[356] + F13*G[416] + F24*G[413] + F25*G[414] + F26*G[415]))) + F31*(F27*(F24*(F2*(F11*G[149] + F12*G[150] + F13*G[151] + F24*G[180]) + F3*(F11*G[150] + F12*G[152] + F13*G[153] + F24*G[187]) + F31*(F11*G[180] + F12*G[187] + F13*G[188] + F24*G[158]) + F4*(F11*G[151] + F12*G[153] + F13*G[154] + F24*G[188])) + F25*(F2*(F11*G[150] + F12*G[178] + F13*G[179] + F24*G[181] + F25*G[183]) + F3*(F11*G[152] + F12*G[202] + F13*G[203] + F24*G[204] + F25*G[206]) + F31*(F11*G[187] + F12*G[183] + F13*G[189] + F24*G[159] + F25*G[438]) + F4*(F11*G[153] + F12*G[220] + F13*G[221] + F24*G[205] + F25*G[223])) + F26*(F2*(F11*G[151] + F12*G[179] + F13*G[186] + F24*G[182] + F25*G[184] + F26*G[185]) + F3*(F11*G[153] + F12*G[203] + F13*G[209] + F24*G[205] + F25*G[207] + F26*G[208]) + F31*(F11*G[188] + F12*G[189] + F13*G[185] + F24*G[160] + F25*G[439] + F26*G[440]) + F4*(F11*G[154] + F12*G[221] + F13*G[226] + F24*G[222] + F25*G[224] + F26*G[225]))) + F28*(F11*(F2*G[149] + F3*G[150] + F31*G[180] + F4*G[151]) + F12*(F2*G[150] + F3*G[152] + F31*G[187] + F4*G[153]) + F13*(F2*G[151] + F3*G[153] + F31*G[188] + F4*G[154]) + F24*(G[158]*(F24 + F31) + G[180]*(F11 + F2) + G[187]*(F12 + F3) + G[188]*(F13 + F4)) + F25*(F12*G[183] + F13*G[189] + F24*G[159] + F25*G[438] + F3*G[210] + F31*G[241] + F4*G[211] + G[187]*(F11 + F2)) + F26*(F12*G[189] + F13*G[185] + F24*G[160] + F25*G[439] + F26*G[440] + F3*G[211] + F31*G[247] + F4*G[227] + G[188]*(F11 + F2))) + F29*(F11*(F2*G[150] + F3*G[152] + F31*G[187] + F4*G[153]) + F12*(F2*G[178] + F3*G[202] + F31*G[183] + F4*G[220]) + F13*(F2*G[179] + F3*G[203] + F31*G[189] + F4*G[221]) + F24*(G[187]*(F11 + F2) + G[210]*(F12 + F3) + G[211]*(F13 + F4) + G[241]*(F24 + F31)) + F25*(F11*G[210] + F13*G[212] + F2*G[183] + F24*G[451] + F25*G[244] + F31*G[438] + F4*G[223] + G[206]*(F12 + F3)) + F26*(F11*G[211] + F13*G[208] + F2*G[189] + F24*G[162] + F25*G[366] + F26*G[459] + F31*G[441] + F4*G[228] + G[212]*(F12 + F3))) + F30*(F11*(F2*G[151] + F3*G[153] + F31*G[188] + F4*G[154]) + F12*(F2*G[179] + F3*G[203] + F31*G[189] + F4*G[221]) + F13*(F2*G[186] + F3*G[209] + F31*G[185] + F4*G[226]) + F24*(G[188]*(F11 + F2) + G[211]*(F12 + F3) + G[227]*(F13 + F4) + G[247]*(F24 + F31)) + F25*(F11*G[211] + F12*G[223] + F2*G[189] + F24*G[162] + F25*G[460] + F3*G[212] + F31*G[441] + G[228]*(F13 + F4)) + F26*(F11*G[227] + F12*G[228] + F2*G[185] + F24*G[458] + F25*G[421] + F26*G[251] + F3*G[208] + F31*G[440] + G[225]*(F13 + F4)))) + F32*(F27*(F24*(F11*(F2*G[150] + F3*G[178] + F31*G[181] + F32*G[183] + F4*G[179]) + F12*(F2*G[152] + F3*G[202] + F31*G[204] + F32*G[206] + F4*G[203]) + F13*(F2*G[153] + F3*G[220] + F31*G[205] + F32*G[223] + F4*G[221]) + F24*(F2*G[187] + F3*G[183] + F31*G[159] + F32*G[438] + F4*G[189])) + F25*(F2*(F11*G[152] + F12*G[202] + F13*G[203] + F24*G[204] + F25*G[206]) + F3*(F11*G[202] + F12*G[339] + F13*G[340] + F24*G[341] + F25*G[343]) + F31*(F11*G[204] + F12*G[341] + F13*G[207] + F24*G[447] + F25*G[365]) + F32*(F11*G[206] + F12*G[343] + F13*G[347] + F24*G[365] + F25*G[367]) + F4*(F11*G[203] + F12*G[340] + F13*G[353] + F24*G[207] + F25*G[347])) + F26*(F2*(F11*G[153] + F12*G[203] + F13*G[209] + F24*G[205] + F25*G[207] + F26*G[208]) + F3*(F11*G[220] + F12*G[340] + F13*G[346] + F24*G[342] + F25*G[344] + F26*G[345]) + F31*(F11*G[205] + F12*G[207] + F13*G[412] + F24*G[448] + F25*G[449] + F26*G[450]) + F32*(F11*G[223] + F12*G[347] + F13*G[345] + F24*G[456] + F25*G[368] + F26*G[465]) + F4*(F11*G[221] + F12*G[353] + F13*G[356] + F24*G[224] + F25*G[354] + F26*G[355]))) + F28*(F11*(F2*G[150] + F3*G[178] + F31*G[181] + F32*G[183] + F4*G[179]) + F12*(F2*G[152] + F3*G[202] + F31*G[204] + F32*G[206] + F4*G[203]) + F13*(F2*G[153] + F3*G[220] + F31*G[205] + F32*G[223] + F4*G[221]) + F24*(F12*G[210] + F13*G[211] + F24*G[241] + F3*G[183] + F31*G[159] + F32*G[438] + F4*G[189] + G[187]*(F11 + F2)) + F25*(G[206]*(F12 + F3) + G[210]*(F11 + F2) + G[212]*(F13 + F4) + G[244]*(F25 + F32) + G[451]*(F24 + F31)) + F26*(F12*G[212] + F13*G[208] + F25*G[366] + F26*G[459] + F3*G[223] + F32*G[460] + F4*G[228] + G[162]*(F24 + F31) + G[211]*(F11 + F2))) + F29*(F11*(F2*G[152] + F3*G[202] + F31*G[204] + F32*G[206] + F4*G[203]) + F12*(F2*G[202] + F3*G[339] + F31*G[341] + F32*G[343] + F4*G[340]) + F13*(F2*G[203] + F3*G[340] + F31*G[207] + F32*G[347] + F4*G[353]) + F24*(F11*G[183] + F13*G[223] + F2*G[210] + F24*G[438] + F31*G[451] + F32*G[244] + F4*G[212] + G[206]*(F12 + F3)) + F25*(G[206]*(F11 + F2) + G[343]*(F12 + F3) + G[347]*(F13 + F4) + G[365]*(F24 + F31) + G[367]*(F25 + F32)) + F26*(F11*G[223] + F13*G[345] + F2*G[212] + F24*G[456] + F25*G[368] + F26*G[465] + F31*G[366] + F32*G[371] + F4*G[357] + G[347]*(F12 + F3))) + F30*(F11*(F2*G[153] + F3*G[220] + F31*G[205] + F32*G[223] + F4*G[221]) + F12*(F2*G[203] + F3*G[340] + F31*G[207] + F32*G[347] + F4*G[353]) + F13*(F2*G[209] + F3*G[346] + F31*G[412] + F32*G[345] + F4*G[356]) + F24*(F11*G[189] + F12*G[212] + F2*G[211] + F24*G[441] + F3*G[223] + F31*G[162] + F32*G[460] + G[228]*(F13 + F4)) + F25*(G[212]*(F11 + F2) + G[347]*(F12 + F3) + G[357]*(F13 + F4) + G[366]*(F24 + F31) + G[371]*(F25 + F32)) + F26*(F11*G[228] + F12*G[357] + F2*G[208] + F24*G[421] + F25*G[469] + F26*G[373] + F3*G[345] + F31*G[450] + F32*G[465] + G[355]*(F13 + F4)))) + F33*(F27*(F24*(F11*(F2*G[151] + F3*G[179] + F31*G[182] + F32*G[184] + F33*G[185] + F4*G[186]) + F12*(F2*G[153] + F3*G[203] + F31*G[205] + F32*G[207] + F33*G[208] + F4*G[209]) + F13*(F2*G[154] + F3*G[221] + F31*G[222] + F32*G[224] + F33*G[225] + F4*G[226]) + F24*(F2*G[188] + F3*G[189] + F31*G[160] + F32*G[439] + F33*G[440] + F4*G[185])) + F25*(F11*(F2*G[153] + F3*G[203] + F31*G[205] + F32*G[207] + F33*G[208] + F4*G[209]) + F12*(F2*G[220] + F3*G[340] + F31*G[342] + F32*G[344] + F33*G[345] + F4*G[346]) + F13*(F2*G[221] + F3*G[353] + F31*G[224] + F32*G[354] + F33*G[355] + F4*G[356]) + F24*(F2*G[205] + F3*G[207] + F31*G[448] + F32*G[449] + F33*G[450] + F4*G[412]) + F25*(F2*G[223] + F3*G[347] + F31*G[456] + F32*G[368] + F33*G[465] + F4*G[345])) + F26*(F2*(F11*G[154] + F12*G[221] + F13*G[226] + F24*G[222] + F25*G[224] + F26*G[225]) + F3*(F11*G[221] + F12*G[353] + F13*G[356] + F24*G[224] + F25*G[354] + F26*G[355]) + F31*(F11*G[222] + F12*G[224] + F13*G[413] + F24*G[455] + F25*G[457] + F26*G[422]) + F32*(F11*G[224] + F12*G[354] + F13*G[414] + F24*G[457] + F25*G[468] + F26*G[423]) + F33*(F11*G[225] + F12*G[355] + F13*G[415] + F24*G[422] + F25*G[423] + F26*G[424]) + F4*(F11*G[226] + F12*G[356] + F13*G[416] + F24*G[413] + F25*G[414] + F26*G[415]))) + F28*(F11*(F2*G[151] + F3*G[179] + F31*G[182] + F32*G[184] + F33*G[185] + F4*G[186]) + F12*(F2*G[153] + F3*G[203] + F31*G[205] + F32*G[207] + F33*G[208] + F4*G[209]) + F13*(F2*G[154] + F3*G[221] + F31*G[222] + F32*G[224] + F33*G[225] + F4*G[226]) + F24*(F12*G[211] + F13*G[227] + F24*G[247] + F3*G[189] + F31*G[160] + F32*G[439] + F33*G[440] + F4*G[185] + G[188]*(F11 + F2)) + F25*(F12*G[223] + F13*G[228] + F25*G[460] + F3*G[212] + F32*G[366] + F33*G[459] + F4*G[208] + G[162]*(F24 + F31) + G[211]*(F11 + F2)) + F26*(G[225]*(F13 + F4) + G[227]*(F11 + F2) + G[228]*(F12 + F3) + G[251]*(F26 + F33) + G[421]*(F25 + F32) + G[458]*(F24 + F31))) + F29*(F11*(F2*G[153] + F3*G[203] + F31*G[205] + F32*G[207] + F33*G[208] + F4*G[209]) + F12*(F2*G[220] + F3*G[340] + F31*G[342] + F32*G[344] + F33*G[345] + F4*G[346]) + F13*(F2*G[221] + F3*G[353] + F31*G[224] + F32*G[354] + F33*G[355] + F4*G[356]) + F24*(F11*G[189] + F13*G[228] + F2*G[211] + F24*G[441] + F31*G[162] + F32*G[366] + F33*G[459] + F4*G[208] + G[212]*(F12 + F3)) + F25*(F11*G[212] + F13*G[357] + F2*G[223] + F24*G[366] + F25*G[371] + F31*G[456] + F32*G[368] + F33*G[465] + F4*G[345] + G[347]*(F12 + F3)) + F26*(G[228]*(F11 + F2) + G[355]*(F13 + F4) + G[357]*(F12 + F3) + G[373]*(F26 + F33) + G[421]*(F24 + F31) + G[469]*(F25 + F32))) + F30*(F11*(F2*G[154] + F3*G[221] + F31*G[222] + F32*G[224] + F33*G[225] + F4*G[226]) + F12*(F2*G[221] + F3*G[353] + F31*G[224] + F32*G[354] + F33*G[355] + F4*G[356]) + F13*(F2*G[226] + F3*G[356] + F31*G[413] + F32*G[414] + F33*G[415] + F4*G[416]) + F24*(F11*G[185] + F12*G[208] + F2*G[227] + F24*G[440] + F3*G[228] + F31*G[458] + F32*G[421] + F33*G[251] + G[225]*(F13 + F4)) + F25*(F11*G[208] + F12*G[345] + F2*G[228] + F24*G[450] + F25*G[465] + F3*G[357] + F31*G[421] + F32*G[469] + F33*G[373] + G[355]*(F13 + F4)) + F26*(G[225]*(F11 + F2) + G[355]*(F12 + F3) + G[415]*(F13 + F4) + G[422]*(F24 + F31) + G[423]*(F25 + F32) + G[424]*(F26 + F33))))) + std::exp(F10)*(F24*(F11*F11*(F28*G[12] + F29*G[10] + F30*G[11]) + F12*(F11*(F28*G[34] + F29*G[32] + F30*G[33]) + F12*(F28*G[15] + F29*G[35] + F30*G[54])) + F13*(F28*(F11*G[53] + F12*G[282] + F13*G[17]) + F29*(F11*G[33] + F12*G[36] + F13*G[38]) + F30*(F11*G[52] + F12*G[55] + F13*G[57]))) + F24*F24*(F27*(F11*F11*G[9] + F12*(F11*G[10] + F12*G[13]) + F13*(F11*G[11] + F12*G[14] + F13*G[16]) + F24*(F11*G[164] + F12*G[213] + F13*G[229] + F24*G[18])) + F28*(F11*G[167] + F12*G[168] + F13*G[169] + F24*G[431]) + F29*(F11*G[168] + F12*G[195] + F13*G[214] + F24*G[19]) + F30*(F11*G[169] + F12*G[214] + F13*G[217] + F24*G[20])) + F25*(F11*F11*(F28*G[10] + F29*G[15] + F30*G[14]) + F12*(F11*(F28*G[32] + F29*G[37] + F30*G[36]) + F12*(F28*G[35] + F29*G[271] + F30*G[270])) + F13*(F28*(F11*G[33] + F12*G[36] + F13*G[38]) + F29*(F11*G[56] + F12*G[284] + F13*G[273]) + F30*(F11*G[55] + F12*G[283] + F13*G[285])) + F24*(F27*(F11*F11*G[10] + F12*(F11*G[32] + F12*G[35]) + F13*(F11*G[33] + F12*G[36] + F13*G[38]) + F24*(F11*G[165] + F12*G[170] + F13*G[327] + F24*G[429])) + F28*(F11*G[172] + F12*G[173] + F13*G[174] + F24*G[434]) + F29*(F11*G[173] + F12*G[330] + F13*G[200] + F24*G[432]) + F30*(F11*G[174] + F12*G[200] + F13*G[405] + F24*G[435])) + F25*(F27*(F11*F11*G[13] + F12*(F11*G[35] + F12*G[269]) + F13*(F11*G[54] + F12*G[270] + F13*G[272]) + F24*(F11*G[170] + F12*G[328] + F13*G[194] + F24*G[432]) + F25*(F11*G[193] + F12*G[332] + F13*G[359] + F24*G[442] + F25*G[274])) + F28*(F11*G[195] + F12*G[196] + F13*G[197] + F24*G[432] + F25*G[42]) + F29*(F11*G[196] + F12*G[334] + F13*G[335] + F24*G[444] + F25*G[462]) + F30*(F11*G[197] + F12*G[335] + F13*G[351] + F24*G[445] + F25*G[275]))) + F26*(F27*(F24*(F11*F11*G[11] + F12*(F11*G[33] + F12*G[54]) + F13*(F11*G[52] + F12*G[55] + F13*G[57]) + F24*(F11*G[166] + F12*G[327] + F13*G[175] + F24*G[430])) + F25*(F11*F11*G[14] + F12*(F11*G[36] + F12*G[270]) + F13*(F11*G[55] + F12*G[283] + F13*G[285]) + F24*(F11*G[171] + F12*G[329] + F13*G[404] + F24*G[433]) + F25*(F11*G[194] + F12*G[333] + F13*G[336] + F24*G[443] + F25*G[461])) + F26*(F11*F11*G[16] + F12*(F11*G[38] + F12*G[272]) + F13*(F11*G[57] + F12*G[285] + F13*G[384]) + F24*(F11*G[175] + F12*G[198] + F13*G[406] + F24*G[436]) + F25*(F11*G[198] + F12*G[336] + F13*G[408] + F24*G[446] + F25*G[463]) + F26*(F11*G[216] + F12*G[350] + F13*G[410] + F24*G[452] + F25*G[466] + F26*G[386]))) + F28*(F11*F11*G[11] + F12*(F11*G[33] + F12*G[54]) + F13*(F11*G[52] + F12*G[55] + F13*G[57]) + F24*(F11*G[176] + F12*G[174] + F13*G[177] + F24*G[437]) + F25*(F11*G[199] + F12*G[200] + F13*G[201] + F24*G[433] + F25*G[445]) + F26*(F11*G[217] + F12*G[218] + F13*G[219] + F24*G[436] + F25*G[453] + F26*G[62])) + F29*(F11*F11*G[14] + F12*(F11*G[36] + F12*G[270]) + F13*(F11*G[55] + F12*G[283] + F13*G[285]) + F24*(F11*G[174] + F12*G[331] + F13*G[201] + F24*G[435]) + F25*(F11*G[200] + F12*G[337] + F13*G[338] + F24*G[443] + F25*G[464]) + F26*(F11*G[218] + F12*G[351] + F13*G[352] + F24*G[453] + F25*G[463] + F26*G[288])) + F30*(F11*F11*G[17] + F12*(F11*G[39] + F12*G[273]) + F13*(F11*G[58] + F12*G[286] + F13*G[385]) + F24*(F11*G[177] + F12*G[201] + F13*G[407] + F24*G[436]) + F25*(F11*G[201] + F12*G[338] + F13*G[409] + F24*G[446] + F25*G[463]) + F26*(F11*G[219] + F12*G[352] + F13*G[411] + F24*G[454] + F25*G[467] + F26*G[470]))))) + F5*(F11*G[254] + F12*G[258] + F13*G[262] + F2*G[253] + F3*G[257] + F4*G[261]) + F6*(F11*G[258] + F12*G[376] + F13*G[380] + F2*G[257] + F3*G[375] + F4*G[379]) + F7*(F11*G[262] + F12*G[380] + F13*G[427] + F2*G[261] + F3*G[379] + F4*G[426]) + G[473]*std::exp(F0) + std::exp(F1)*(G[476] + F28*F28*(F2*(F11*G[149] + F12*G[150] + F13*G[151] + F24*G[180] + F25*G[187] + F26*G[188]) + F3*(F11*G[150] + F12*G[152] + F13*G[153] + F24*G[187] + F25*G[210] + F26*G[211]) + F31*(F11*G[180] + F12*G[187] + F13*G[188] + F24*G[158] + F25*G[241] + F26*G[247]) + F32*(F11*G[187] + F12*G[210] + F13*G[211] + F24*G[241] + F25*G[161] + F26*G[370]) + F33*(F11*G[188] + F12*G[211] + F13*G[227] + F24*G[247] + F25*G[370] + F26*G[163]) + F4*(F11*G[151] + F12*G[153] + F13*G[154] + F24*G[188] + F25*G[211] + F26*G[227])) + F29*(F28*(F2*(F11*G[155] + F12*G[231] + F13*G[234] + F24*G[181] + F25*G[232] + F26*G[233]) + F3*(F11*G[231] + F12*G[360] + F13*G[237] + F24*G[232] + F25*G[341] + F26*G[238]) + F31*(F11*G[181] + F12*G[232] + F13*G[233] + F24*G[159] + F25*G[242] + F26*G[243]) + F32*(F11*G[232] + F12*G[341] + F13*G[238] + F24*G[242] + F25*G[365] + F26*G[245]) + F33*(F11*G[233] + F12*G[238] + F13*G[224] + F24*G[243] + F25*G[245] + F26*G[421]) + F4*(F11*G[234] + F12*G[237] + F13*G[418] + F24*G[233] + F25*G[238] + F26*G[224])) + F29*(F2*(F11*G[152] + F12*G[202] + F13*G[203] + F24*G[210] + F25*G[206] + F26*G[212]) + F3*(F11*G[202] + F12*G[339] + F13*G[340] + F24*G[206] + F25*G[343] + F26*G[347]) + F31*(F11*G[210] + F12*G[206] + F13*G[212] + F24*G[161] + F25*G[244] + F26*G[249]) + F32*(F11*G[206] + F12*G[343] + F13*G[347] + F24*G[244] + F25*G[367] + F26*G[371]) + F33*(F11*G[212] + F12*G[347] + F13*G[357] + F24*G[249] + F25*G[371] + F26*G[369]) + F4*(F11*G[203] + F12*G[340] + F13*G[353] + F24*G[212] + F25*G[347] + F26*G[357]))) + F30*(F28*(F2*(F11*G[156] + F12*G[234] + F13*G[236] + F24*G[182] + F25*G[233] + F26*G[235]) + F3*(F11*G[234] + F12*G[361] + F13*G[240] + F24*G[233] + F25*G[207] + F26*G[239]) + F31*(F11*G[182] + F12*G[233] + F13*G[235] + F24*G[160] + F25*G[243] + F26*G[248]) + F32*(F11*G[233] + F12*G[207] + F13*G[239] + F24*G[243] + F25*G[366] + F26*G[250]) + F33*(F11*G[235] + F12*G[239] + F13*G[413] + F24*G[248] + F25*G[250] + F26*G[422]) + F4*(F11*G[236] + F12*G[240] + F13*G[419] + F24*G[235] + F25*G[239] + F26*G[413])) + F29*(F2*(F11*G[157] + F12*G[237] + F13*G[240] + F24*G[205] + F25*G[238] + F26*G[239]) + F3*(F11*G[237] + F12*G[362] + F13*G[364] + F24*G[238] + F25*G[344] + F26*G[363]) + F31*(F11*G[205] + F12*G[238] + F13*G[239] + F24*G[162] + F25*G[245] + F26*G[250]) + F32*(F11*G[238] + F12*G[344] + F13*G[363] + F24*G[245] + F25*G[368] + F26*G[372]) + F33*(F11*G[239] + F12*G[363] + F13*G[414] + F24*G[250] + F25*G[372] + F26*G[423]) + F4*(F11*G[240] + F12*G[364] + F13*G[420] + F24*G[239] + F25*G[363] + F26*G[414])) + F30*(F2*(F11*G[154] + F12*G[221] + F13*G[226] + F24*G[227] + F25*G[228] + F26*G[225]) + F3*(F11*G[221] + F12*G[353] + F13*G[356] + F24*G[228] + F25*G[357] + F26*G[355]) + F31*(F11*G[227] + F12*G[228] + F13*G[225] + F24*G[163] + F25*G[246] + F26*G[251]) + F32*(F11*G[228] + F12*G[357] + F13*G[355] + F24*G[246] + F25*G[369] + F26*G[373]) + F33*(F11*G[225] + F12*G[355] + F13*G[415] + F24*G[251] + F25*G[373] + F26*G[424]) + F4*(F11*G[226] + F12*G[356] + F13*G[416] + F24*G[225] + F25*G[355] + F26*G[415])))) + std::exp(F10)*(G[475] + F28*F28*(F11*F11*G[9] + F12*(F11*G[10] + F12*G[13]) + F13*(F11*G[11] + F12*G[14] + F13*G[16]) + F24*(F11*G[164] + F12*G[213] + F13*G[229] + F24*G[18]) + F25*(F11*G[213] + F12*G[190] + F13*G[358] + F24*G[19] + F25*G[21]) + F26*(F11*G[229] + F12*G[358] + F13*G[192] + F24*G[20] + F25*G[22] + F26*G[23])) + F29*(F28*(F11*F11*G[10] + F12*(F11*G[32] + F12*G[35]) + F13*(F11*G[33] + F12*G[36] + F13*G[38]) + F24*(F11*G[168] + F12*G[195] + F13*G[214] + F24*G[19]) + F25*(F11*G[195] + F12*G[196] + F13*G[197] + F24*G[40] + F25*G[42]) + F26*(F11*G[214] + F12*G[197] + F13*G[417] + F24*G[41] + F25*G[43] + F26*G[44])) + F29*(F11*F11*G[13] + F12*(F11*G[35] + F12*G[269]) + F13*(F11*G[54] + F12*G[270] + F13*G[272]) + F24*(F11*G[190] + F12*G[193] + F13*G[230] + F24*G[21]) + F25*(F11*G[193] + F12*G[332] + F13*G[359] + F24*G[42] + F25*G[274]) + F26*(F11*G[230] + F12*G[359] + F13*G[349] + F24*G[60] + F25*G[275] + F26*G[276]))) + F30*(F28*(F11*F11*G[11] + F12*(F11*G[33] + F12*G[54]) + F13*(F11*G[52] + F12*G[55] + F13*G[57]) + F24*(F11*G[169] + F12*G[214] + F13*G[217] + F24*G[20]) + F25*(F11*G[214] + F12*G[348] + F13*G[218] + F24*G[41] + F25*G[60]) + F26*(F11*G[217] + F12*G[218] + F13*G[219] + F24*G[59] + F25*G[61] + F26*G[62])) + F29*(F11*F11*G[14] + F12*(F11*G[36] + F12*G[270]) + F13*(F11*G[55] + F12*G[283] + F13*G[285]) + F24*(F11*G[191] + F12*G[197] + F13*G[218] + F24*G[22]) + F25*(F11*G[197] + F12*G[335] + F13*G[351] + F24*G[43] + F25*G[275]) + F26*(F11*G[218] + F12*G[351] + F13*G[352] + F24*G[61] + F25*G[287] + F26*G[288])) + F30*(F11*F11*G[16] + F12*(F11*G[38] + F12*G[272]) + F13*(F11*G[57] + F12*G[285] + F13*G[384]) + F24*(F11*G[192] + F12*G[215] + F13*G[216] + F24*G[23]) + F25*(F11*G[215] + F12*G[349] + F13*G[350] + F24*G[44] + F25*G[276]) + F26*(F11*G[216] + F12*G[350] + F13*G[410] + F24*G[62] + F25*G[288] + F26*G[386]))))) + std::exp(F9)*(F17*(std::exp(F0)*(F14*(F2*(F18*(F11*G[77] + F12*G[78] + F13*G[79] + F14*G[80]) + F19*(F11*G[78] + F12*G[104] + F13*G[105] + F14*G[89]) + F20*(F11*G[79] + F12*G[105] + F13*G[124] + F14*G[90])) + F3*(F18*(F11*G[78] + F12*G[104] + F13*G[105] + F14*G[89]) + F19*(F11*G[85] + F12*G[110] + F13*G[128] + F14*G[83]) + F20*(F11*G[86] + F12*G[111] + F13*G[129] + F14*G[91])) + F4*(F18*(F11*G[79] + F12*G[105] + F13*G[124] + F14*G[90]) + F19*(F11*G[86] + F12*G[111] + F13*G[129] + F14*G[91]) + F20*(F11*G[88] + F12*G[113] + F13*G[131] + F14*G[87]))) + F15*(F2*(F18*(F11*G[78] + F12*G[85] + F13*G[86] + F14*G[81] + F15*G[83]) + F19*(F11*G[104] + F12*G[110] + F13*G[111] + F14*G[106] + F15*G[108]) + F20*(F11*G[105] + F12*G[128] + F13*G[129] + F14*G[107] + F15*G[126])) + F3*(F18*(F11*G[104] + F12*G[110] + F13*G[111] + F14*G[106] + F15*G[108]) + F19*(F11*G[110] + F12*G[305] + F13*G[306] + F14*G[301] + F15*G[303]) + F20*(F11*G[111] + F12*G[306] + F13*G[316] + F14*G[109] + F15*G[309])) + F4*(F18*(F11*G[105] + F12*G[128] + F13*G[129] + F14*G[107] + F15*G[126]) + F19*(F11*G[111] + F12*G[306] + F13*G[316] + F14*G[109] + F15*G[309]) + F20*(F11*G[113] + F12*G[308] + F13*G[318] + F14*G[395] + F15*G[307]))) + F16*(F2*(F18*(F11*G[79] + F12*G[86] + F13*G[88] + F14*G[82] + F15*G[84] + F16*G[87]) + F19*(F11*G[105] + F12*G[111] + F13*G[113] + F14*G[107] + F15*G[109] + F16*G[112]) + F20*(F11*G[124] + F12*G[129] + F13*G[131] + F14*G[125] + F15*G[127] + F16*G[130])) + F3*(F18*(F11*G[105] + F12*G[111] + F13*G[113] + F14*G[107] + F15*G[109] + F16*G[112]) + F19*(F11*G[128] + F12*G[306] + F13*G[308] + F14*G[302] + F15*G[304] + F16*G[307]) + F20*(F11*G[129] + F12*G[316] + F13*G[318] + F14*G[127] + F15*G[315] + F16*G[317])) + F4*(F18*(F11*G[124] + F12*G[129] + F13*G[131] + F14*G[125] + F15*G[127] + F16*G[130]) + F19*(F11*G[129] + F12*G[316] + F13*G[318] + F14*G[127] + F15*G[315] + F16*G[317]) + F20*(F11*G[131] + F12*G[318] + F13*G[399] + F14*G[396] + F15*G[397] + F16*G[398]))) + F21*(F17*(F14*(F2*(F11*G[77] + F12*G[78] + F13*G[79] + F14*G[80]) + F21*(F11*G[80] + F12*G[89] + F13*G[90] + F14*G[158]) + F3*(F11*G[78] + F12*G[104] + F13*G[105] + F14*G[89]) + F4*(F11*G[79] + F12*G[105] + F13*G[124] + F14*G[90])) + F15*(F2*(F11*G[78] + F12*G[85] + F13*G[86] + F14*G[81] + F15*G[83]) + F21*(F11*G[89] + F12*G[83] + F13*G[91] + F14*G[159] + F15*G[438]) + F3*(F11*G[104] + F12*G[110] + F13*G[111] + F14*G[106] + F15*G[108]) + F4*(F11*G[105] + F12*G[128] + F13*G[129] + F14*G[107] + F15*G[126])) + F16*(F2*(F11*G[79] + F12*G[86] + F13*G[88] + F14*G[82] + F15*G[84] + F16*G[87]) + F21*(F11*G[90] + F12*G[91] + F13*G[87] + F14*G[160] + F15*G[439] + F16*G[440]) + F3*(F11*G[105] + F12*G[111] + F13*G[113] + F14*G[107] + F15*G[109] + F16*G[112]) + F4*(F11*G[124] + F12*G[129] + F13*G[131] + F14*G[125] + F15*G[127] + F16*G[130]))) + F18*(F11*(F2*G[77] + F21*G[80] + F3*G[78] + F4*G[79]) + F12*(F2*G[78] + F21*G[89] + F3*G[104] + F4*G[105]) + F13*(F2*G[79] + F21*G[90] + F3*G[105] + F4*G[124]) + F14*(G[158]*(F14 + F21) + G[80]*(F11 + F2) + G[89]*(F12 + F3) + G[90]*(F13 + F4)) + F15*(F12*G[83] + F13*G[91] + F14*G[159] + F15*G[438] + F21*G[241] + F3*G[114] + F4*G[115] + G[89]*(F11 + F2)) + F16*(F12*G[91] + F13*G[87] + F14*G[160] + F15*G[439] + F16*G[440] + F21*G[247] + F3*G[115] + F4*G[132] + G[90]*(F11 + F2))) + F19*(F11*(F2*G[78] + F21*G[89] + F3*G[104] + F4*G[105]) + F12*(F2*G[85] + F21*G[83] + F3*G[110] + F4*G[128]) + F13*(F2*G[86] + F21*G[91] + F3*G[111] + F4*G[129]) + F14*(G[114]*(F12 + F3) + G[115]*(F13 + F4) + G[241]*(F14 + F21) + G[89]*(F11 + F2)) + F15*(F11*G[114] + F13*G[116] + F14*G[451] + F15*G[244] + F2*G[83] + F21*G[438] + F4*G[126] + G[108]*(F12 + F3)) + F16*(F11*G[115] + F13*G[112] + F14*G[162] + F15*G[366] + F16*G[459] + F2*G[91] + F21*G[441] + F4*G[133] + G[116]*(F12 + F3))) + F20*(F11*(F2*G[79] + F21*G[90] + F3*G[105] + F4*G[124]) + F12*(F2*G[86] + F21*G[91] + F3*G[111] + F4*G[129]) + F13*(F2*G[88] + F21*G[87] + F3*G[113] + F4*G[131]) + F14*(G[115]*(F12 + F3) + G[132]*(F13 + F4) + G[247]*(F14 + F21) + G[90]*(F11 + F2)) + F15*(F11*G[115] + F12*G[126] + F14*G[162] + F15*G[460] + F2*G[91] + F21*G[441] + F3*G[116] + G[133]*(F13 + F4)) + F16*(F11*G[132] + F12*G[133] + F14*G[458] + F15*G[421] + F16*G[251] + F2*G[87] + F21*G[440] + F3*G[112] + G[130]*(F13 + F4)))) + F22*(F17*(F14*(F11*(F2*G[78] + F21*G[81] + F22*G[83] + F3*G[85] + F4*G[86]) + F12*(F2*G[104] + F21*G[106] + F22*G[108] + F3*G[110] + F4*G[111]) + F13*(F2*G[105] + F21*G[107] + F22*G[126] + F3*G[128] + F4*G[129]) + F14*(F2*G[89] + F21*G[159] + F22*G[438] + F3*G[83] + F4*G[91])) + F15*(F2*(F11*G[104] + F12*G[110] + F13*G[111] + F14*G[106] + F15*G[108]) + F21*(F11*G[106] + F12*G[301] + F13*G[109] + F14*G[447] + F15*G[365]) + F22*(F11*G[108] + F12*G[303] + F13*G[309] + F14*G[365] + F15*G[367]) + F3*(F11*G[110] + F12*G[305] + F13*G[306] + F14*G[301] + F15*G[303]) + F4*(F11*G[111] + F12*G[306] + F13*G[316] + F14*G[109] + F15*G[309])) + F16*(F2*(F11*G[105] + F12*G[111] + F13*G[113] + F14*G[107] + F15*G[109] + F16*G[112]) + F21*(F11*G[107] + F12*G[109] + F13*G[395] + F14*G[448] + F15*G[449] + F16*G[450]) + F22*(F11*G[126] + F12*G[309] + F13*G[307] + F14*G[456] + F15*G[368] + F16*G[465]) + F3*(F11*G[128] + F12*G[306] + F13*G[308] + F14*G[302] + F15*G[304] + F16*G[307]) + F4*(F11*G[129] + F12*G[316] + F13*G[318] + F14*G[127] + F15*G[315] + F16*G[317]))) + F18*(F11*(F2*G[78] + F21*G[81] + F22*G[83] + F3*G[85] + F4*G[86]) + F12*(F2*G[104] + F21*G[106] + F22*G[108] + F3*G[110] + F4*G[111]) + F13*(F2*G[105] + F21*G[107] + F22*G[126] + F3*G[128] + F4*G[129]) + F14*(F12*G[114] + F13*G[115] + F14*G[241] + F21*G[159] + F22*G[438] + F3*G[83] + F4*G[91] + G[89]*(F11 + F2)) + F15*(G[108]*(F12 + F3) + G[114]*(F11 + F2) + G[116]*(F13 + F4) + G[244]*(F15 + F22) + G[451]*(F14 + F21)) + F16*(F12*G[116] + F13*G[112] + F15*G[366] + F16*G[459] + F22*G[460] + F3*G[126] + F4*G[133] + G[115]*(F11 + F2) + G[162]*(F14 + F21))) + F19*(F11*(F2*G[104] + F21*G[106] + F22*G[108] + F3*G[110] + F4*G[111]) + F12*(F2*G[110] + F21*G[301] + F22*G[303] + F3*G[305] + F4*G[306]) + F13*(F2*G[111] + F21*G[109] + F22*G[309] + F3*G[306] + F4*G[316]) + F14*(F11*G[83] + F13*G[126] + F14*G[438] + F2*G[114] + F21*G[451] + F22*G[244] + F4*G[116] + G[108]*(F12 + F3)) + F15*(G[108]*(F11 + F2) + G[303]*(F12 + F3) + G[309]*(F13 + F4) + G[365]*(F14 + F21) + G[367]*(F15 + F22)) + F16*(F11*G[126] + F13*G[307] + F14*G[456] + F15*G[368] + F16*G[465] + F2*G[116] + F21*G[366] + F22*G[371] + F4*G[319] + G[309]*(F12 + F3))) + F20*(F11*(F2*G[105] + F21*G[107] + F22*G[126] + F3*G[128] + F4*G[129]) + F12*(F2*G[111] + F21*G[109] + F22*G[309] + F3*G[306] + F4*G[316]) + F13*(F2*G[113] + F21*G[395] + F22*G[307] + F3*G[308] + F4*G[318]) + F14*(F11*G[91] + F12*G[116] + F14*G[441] + F2*G[115] + F21*G[162] + F22*G[460] + F3*G[126] + G[133]*(F13 + F4)) + F15*(G[116]*(F11 + F2) + G[309]*(F12 + F3) + G[319]*(F13 + F4) + G[366]*(F14 + F21) + G[371]*(F15 + F22)) + F16*(F11*G[133] + F12*G[319] + F14*G[421] + F15*G[469] + F16*G[373] + F2*G[112] + F21*G[450] + F22*G[465] + F3*G[307] + G[317]*(F13 + F4)))) + F23*(F17*(F14*(F11*(F2*G[79] + F21*G[82] + F22*G[84] + F23*G[87] + F3*G[86] + F4*G[88]) + F12*(F2*G[105] + F21*G[107] + F22*G[109] + F23*G[112] + F3*G[111] + F4*G[113]) + F13*(F2*G[124] + F21*G[125] + F22*G[127] + F23*G[130] + F3*G[129] + F4*G[131]) + F14*(F2*G[90] + F21*G[160] + F22*G[439] + F23*G[440] + F3*G[91] + F4*G[87])) + F15*(F11*(F2*G[105] + F21*G[107] + F22*G[109] + F23*G[112] + F3*G[111] + F4*G[113]) + F12*(F2*G[128] + F21*G[302] + F22*G[304] + F23*G[307] + F3*G[306] + F4*G[308]) + F13*(F2*G[129] + F21*G[127] + F22*G[315] + F23*G[317] + F3*G[316] + F4*G[318]) + F14*(F2*G[107] + F21*G[448] + F22*G[449] + F23*G[450] + F3*G[109] + F4*G[395]) + F15*(F2*G[126] + F21*G[456] + F22*G[368] + F23*G[465] + F3*G[309] + F4*G[307])) + F16*(F2*(F11*G[124] + F12*G[129] + F13*G[131] + F14*G[125] + F15*G[127] + F16*G[130]) + F21*(F11*G[125] + F12*G[127] + F13*G[396] + F14*G[455] + F15*G[457] + F16*G[422]) + F22*(F11*G[127] + F12*G[315] + F13*G[397] + F14*G[457] + F15*G[468] + F16*G[423]) + F23*(F11*G[130] + F12*G[317] + F13*G[398] + F14*G[422] + F15*G[423] + F16*G[424]) + F3*(F11*G[129] + F12*G[316] + F13*G[318] + F14*G[127] + F15*G[315] + F16*G[317]) + F4*(F11*G[131] + F12*G[318] + F13*G[399] + F14*G[396] + F15*G[397] + F16*G[398]))) + F18*(F11*(F2*G[79] + F21*G[82] + F22*G[84] + F23*G[87] + F3*G[86] + F4*G[88]) + F12*(F2*G[105] + F21*G[107] + F22*G[109] + F23*G[112] + F3*G[111] + F4*G[113]) + F13*(F2*G[124] + F21*G[125] + F22*G[127] + F23*G[130] + F3*G[129] + F4*G[131]) + F14*(F12*G[115] + F13*G[132] + F14*G[247] + F21*G[160] + F22*G[439] + F23*G[440] + F3*G[91] + F4*G[87] + G[90]*(F11 + F2)) + F15*(F12*G[126] + F13*G[133] + F15*G[460] + F22*G[366] + F23*G[459] + F3*G[116] + F4*G[112] + G[115]*(F11 + F2) + G[162]*(F14 + F21)) + F16*(G[130]*(F13 + F4) + G[132]*(F11 + F2) + G[133]*(F12 + F3) + G[251]*(F16 + F23) + G[421]*(F15 + F22) + G[458]*(F14 + F21))) + F19*(F11*(F2*G[105] + F21*G[107] + F22*G[109] + F23*G[112] + F3*G[111] + F4*G[113]) + F12*(F2*G[128] + F21*G[302] + F22*G[304] + F23*G[307] + F3*G[306] + F4*G[308]) + F13*(F2*G[129] + F21*G[127] + F22*G[315] + F23*G[317] + F3*G[316] + F4*G[318]) + F14*(F11*G[91] + F13*G[133] + F14*G[441] + F2*G[115] + F21*G[162] + F22*G[366] + F23*G[459] + F4*G[112] + G[116]*(F12 + F3)) + F15*(F11*G[116] + F13*G[319] + F14*G[366] + F15*G[371] + F2*G[126] + F21*G[456] + F22*G[368] + F23*G[465] + F4*G[307] + G[309]*(F12 + F3)) + F16*(G[133]*(F11 + F2) + G[317]*(F13 + F4) + G[319]*(F12 + F3) + G[373]*(F16 + F23) + G[421]*(F14 + F21) + G[469]*(F15 + F22))) + F20*(F11*(F2*G[124] + F21*G[125] + F22*G[127] + F23*G[130] + F3*G[129] + F4*G[131]) + F12*(F2*G[129] + F21*G[127] + F22*G[315] + F23*G[317] + F3*G[316] + F4*G[318]) + F13*(F2*G[131] + F21*G[396] + F22*G[397] + F23*G[398] + F3*G[318] + F4*G[399]) + F14*(F11*G[87] + F12*G[112] + F14*G[440] + F2*G[132] + F21*G[458] + F22*G[421] + F23*G[251] + F3*G[133] + G[130]*(F13 + F4)) + F15*(F11*G[112] + F12*G[307] + F14*G[450] + F15*G[465] + F2*G[133] + F21*G[421] + F22*G[469] + F23*G[373] + F3*G[319] + G[317]*(F13 + F4)) + F16*(G[130]*(F11 + F2) + G[317]*(F12 + F3) + G[398]*(F13 + F4) + G[422]*(F14 + F21) + G[423]*(F15 + F22) + G[424]*(F16 + F23))))) + std::exp(F9)*(F14*(F11*F11*(F18*G[3] + F19*G[1] + F20*G[2]) + F12*(F11*(F18*G[26] + F19*G[24] + F20*G[25]) + F12*(F18*G[6] + F19*G[27] + F20*G[47])) + F13*(F18*(F11*G[46] + F12*G[277] + F13*G[8]) + F19*(F11*G[25] + F12*G[28] + F13*G[30]) + F20*(F11*G[45] + F12*G[48] + F13*G[50]))) + F14*F14*(F17*(F11*F11*G[0] + F12*(F11*G[1] + F12*G[4]) + F13*(F11*G[2] + F12*G[5] + F13*G[7]) + F14*(F11*G[63] + F12*G[117] + F13*G[134] + F14*G[18])) + F18*(F11*G[66] + F12*G[67] + F13*G[68] + F14*G[431]) + F19*(F11*G[67] + F12*G[97] + F13*G[118] + F14*G[19]) + F20*(F11*G[68] + F12*G[118] + F13*G[121] + F14*G[20])) + F15*(F11*F11*(F18*G[1] + F19*G[6] + F20*G[5]) + F12*(F11*(F18*G[24] + F19*G[29] + F20*G[28]) + F12*(F18*G[27] + F19*G[266] + F20*G[265])) + F13*(F18*(F11*G[25] + F12*G[28] + F13*G[30]) + F19*(F11*G[49] + F12*G[279] + F13*G[268]) + F20*(F11*G[48] + F12*G[278] + F13*G[280])) + F14*(F17*(F11*F11*G[1] + F12*(F11*G[24] + F12*G[27]) + F13*(F11*G[25] + F12*G[28] + F13*G[30]) + F14*(F11*G[64] + F12*G[69] + F13*G[289] + F14*G[429])) + F18*(F11*G[71] + F12*G[72] + F13*G[73] + F14*G[434]) + F19*(F11*G[72] + F12*G[292] + F13*G[102] + F14*G[432]) + F20*(F11*G[73] + F12*G[102] + F13*G[388] + F14*G[435])) + F15*(F17*(F11*F11*G[4] + F12*(F11*G[27] + F12*G[264]) + F13*(F11*G[47] + F12*G[265] + F13*G[267]) + F14*(F11*G[69] + F12*G[290] + F13*G[96] + F14*G[432]) + F15*(F11*G[95] + F12*G[294] + F13*G[321] + F14*G[442] + F15*G[274])) + F18*(F11*G[97] + F12*G[98] + F13*G[99] + F14*G[432] + F15*G[42]) + F19*(F11*G[98] + F12*G[296] + F13*G[297] + F14*G[444] + F15*G[462]) + F20*(F11*G[99] + F12*G[297] + F13*G[313] + F14*G[445] + F15*G[275]))) + F16*(F17*(F14*(F11*F11*G[2] + F12*(F11*G[25] + F12*G[47]) + F13*(F11*G[45] + F12*G[48] + F13*G[50]) + F14*(F11*G[65] + F12*G[289] + F13*G[74] + F14*G[430])) + F15*(F11*F11*G[5] + F12*(F11*G[28] + F12*G[265]) + F13*(F11*G[48] + F12*G[278] + F13*G[280]) + F14*(F11*G[70] + F12*G[291] + F13*G[387] + F14*G[433]) + F15*(F11*G[96] + F12*G[295] + F13*G[298] + F14*G[443] + F15*G[461])) + F16*(F11*F11*G[7] + F12*(F11*G[30] + F12*G[267]) + F13*(F11*G[50] + F12*G[280] + F13*G[382]) + F14*(F11*G[74] + F12*G[100] + F13*G[389] + F14*G[436]) + F15*(F11*G[100] + F12*G[298] + F13*G[391] + F14*G[446] + F15*G[463]) + F16*(F11*G[120] + F12*G[312] + F13*G[393] + F14*G[452] + F15*G[466] + F16*G[386]))) + F18*(F11*F11*G[2] + F12*(F11*G[25] + F12*G[47]) + F13*(F11*G[45] + F12*G[48] + F13*G[50]) + F14*(F11*G[75] + F12*G[73] + F13*G[76] + F14*G[437]) + F15*(F11*G[101] + F12*G[102] + F13*G[103] + F14*G[433] + F15*G[445]) + F16*(F11*G[121] + F12*G[122] + F13*G[123] + F14*G[436] + F15*G[453] + F16*G[62])) + F19*(F11*F11*G[5] + F12*(F11*G[28] + F12*G[265]) + F13*(F11*G[48] + F12*G[278] + F13*G[280]) + F14*(F11*G[73] + F12*G[293] + F13*G[103] + F14*G[435]) + F15*(F11*G[102] + F12*G[299] + F13*G[300] + F14*G[443] + F15*G[464]) + F16*(F11*G[122] + F12*G[313] + F13*G[314] + F14*G[453] + F15*G[463] + F16*G[288])) + F20*(F11*F11*G[8] + F12*(F11*G[31] + F12*G[268]) + F13*(F11*G[51] + F12*G[281] + F13*G[383]) + F14*(F11*G[76] + F12*G[103] + F13*G[390] + F14*G[436]) + F15*(F11*G[103] + F12*G[300] + F13*G[392] + F14*G[446] + F15*G[463]) + F16*(F11*G[123] + F12*G[314] + F13*G[394] + F14*G[454] + F15*G[467] + F16*G[470]))))) + F5*(F11*G[255] + F12*G[259] + F13*G[263] + F2*G[252] + F3*G[256] + F4*G[260]) + F6*(F11*G[259] + F12*G[377] + F13*G[381] + F2*G[256] + F3*G[374] + F4*G[378]) + F7*(F11*G[263] + F12*G[381] + F13*G[428] + F2*G[260] + F3*G[378] + F4*G[425]) + G[472]*std::exp(F10) + G[473]*std::exp(F1) + std::exp(F0)*(G[474] + F18*F18*(F2*(F11*G[77] + F12*G[78] + F13*G[79] + F14*G[80] + F15*G[89] + F16*G[90]) + F21*(F11*G[80] + F12*G[89] + F13*G[90] + F14*G[158] + F15*G[241] + F16*G[247]) + F22*(F11*G[89] + F12*G[114] + F13*G[115] + F14*G[241] + F15*G[161] + F16*G[370]) + F23*(F11*G[90] + F12*G[115] + F13*G[132] + F14*G[247] + F15*G[370] + F16*G[163]) + F3*(F11*G[78] + F12*G[104] + F13*G[105] + F14*G[89] + F15*G[114] + F16*G[115]) + F4*(F11*G[79] + F12*G[105] + F13*G[124] + F14*G[90] + F15*G[115] + F16*G[132])) + F19*(F18*(F2*(F11*G[136] + F12*G[139] + F13*G[140] + F14*G[81] + F15*G[137] + F16*G[138]) + F21*(F11*G[81] + F12*G[137] + F13*G[138] + F14*G[159] + F15*G[242] + F16*G[243]) + F22*(F11*G[137] + F12*G[301] + F13*G[145] + F14*G[242] + F15*G[365] + F16*G[245]) + F23*(F11*G[138] + F12*G[145] + F13*G[127] + F14*G[243] + F15*G[245] + F16*G[421]) + F3*(F11*G[139] + F12*G[322] + F13*G[147] + F14*G[137] + F15*G[301] + F16*G[145]) + F4*(F11*G[140] + F12*G[147] + F13*G[401] + F14*G[138] + F15*G[145] + F16*G[127])) + F19*(F2*(F11*G[104] + F12*G[110] + F13*G[111] + F14*G[114] + F15*G[108] + F16*G[116]) + F21*(F11*G[114] + F12*G[108] + F13*G[116] + F14*G[161] + F15*G[244] + F16*G[249]) + F22*(F11*G[108] + F12*G[303] + F13*G[309] + F14*G[244] + F15*G[367] + F16*G[371]) + F23*(F11*G[116] + F12*G[309] + F13*G[319] + F14*G[249] + F15*G[371] + F16*G[369]) + F3*(F11*G[110] + F12*G[305] + F13*G[306] + F14*G[108] + F15*G[303] + F16*G[309]) + F4*(F11*G[111] + F12*G[306] + F13*G[316] + F14*G[116] + F15*G[309] + F16*G[319]))) + F20*(F18*(F2*(F11*G[141] + F12*G[140] + F13*G[143] + F14*G[82] + F15*G[138] + F16*G[142]) + F21*(F11*G[82] + F12*G[138] + F13*G[142] + F14*G[160] + F15*G[243] + F16*G[248]) + F22*(F11*G[138] + F12*G[109] + F13*G[146] + F14*G[243] + F15*G[366] + F16*G[250]) + F23*(F11*G[142] + F12*G[146] + F13*G[396] + F14*G[248] + F15*G[250] + F16*G[422]) + F3*(F11*G[140] + F12*G[323] + F13*G[148] + F14*G[138] + F15*G[109] + F16*G[146]) + F4*(F11*G[143] + F12*G[148] + F13*G[402] + F14*G[142] + F15*G[146] + F16*G[396])) + F19*(F2*(F11*G[144] + F12*G[147] + F13*G[148] + F14*G[107] + F15*G[145] + F16*G[146]) + F21*(F11*G[107] + F12*G[145] + F13*G[146] + F14*G[162] + F15*G[245] + F16*G[250]) + F22*(F11*G[145] + F12*G[304] + F13*G[324] + F14*G[245] + F15*G[368] + F16*G[372]) + F23*(F11*G[146] + F12*G[324] + F13*G[397] + F14*G[250] + F15*G[372] + F16*G[423]) + F3*(F11*G[147] + F12*G[325] + F13*G[326] + F14*G[145] + F15*G[304] + F16*G[324]) + F4*(F11*G[148] + F12*G[326] + F13*G[403] + F14*G[146] + F15*G[324] + F16*G[397])) + F20*(F2*(F11*G[124] + F12*G[129] + F13*G[131] + F14*G[132] + F15*G[133] + F16*G[130]) + F21*(F11*G[132] + F12*G[133] + F13*G[130] + F14*G[163] + F15*G[246] + F16*G[251]) + F22*(F11*G[133] + F12*G[319] + F13*G[317] + F14*G[246] + F15*G[369] + F16*G[373]) + F23*(F11*G[130] + F12*G[317] + F13*G[398] + F14*G[251] + F15*G[373] + F16*G[424]) + F3*(F11*G[129] + F12*G[316] + F13*G[318] + F14*G[133] + F15*G[319] + F16*G[317]) + F4*(F11*G[131] + F12*G[318] + F13*G[399] + F14*G[130] + F15*G[317] + F16*G[398])))) + std::exp(F9)*(G[471] + F18*F18*(F11*F11*G[0] + F12*(F11*G[1] + F12*G[4]) + F13*(F11*G[2] + F12*G[5] + F13*G[7]) + F14*(F11*G[63] + F12*G[117] + F13*G[134] + F14*G[18]) + F15*(F11*G[117] + F12*G[92] + F13*G[320] + F14*G[19] + F15*G[21]) + F16*(F11*G[134] + F12*G[320] + F13*G[94] + F14*G[20] + F15*G[22] + F16*G[23])) + F19*(F18*(F11*F11*G[1] + F12*(F11*G[24] + F12*G[27]) + F13*(F11*G[25] + F12*G[28] + F13*G[30]) + F14*(F11*G[67] + F12*G[97] + F13*G[118] + F14*G[19]) + F15*(F11*G[97] + F12*G[98] + F13*G[99] + F14*G[40] + F15*G[42]) + F16*(F11*G[118] + F12*G[99] + F13*G[400] + F14*G[41] + F15*G[43] + F16*G[44])) + F19*(F11*F11*G[4] + F12*(F11*G[27] + F12*G[264]) + F13*(F11*G[47] + F12*G[265] + F13*G[267]) + F14*(F11*G[92] + F12*G[95] + F13*G[135] + F14*G[21]) + F15*(F11*G[95] + F12*G[294] + F13*G[321] + F14*G[42] + F15*G[274]) + F16*(F11*G[135] + F12*G[321] + F13*G[311] + F14*G[60] + F15*G[275] + F16*G[276]))) + F20*(F18*(F11*F11*G[2] + F12*(F11*G[25] + F12*G[47]) + F13*(F11*G[45] + F12*G[48] + F13*G[50]) + F14*(F11*G[68] + F12*G[118] + F13*G[121] + F14*G[20]) + F15*(F11*G[118] + F12*G[310] + F13*G[122] + F14*G[41] + F15*G[60]) + F16*(F11*G[121] + F12*G[122] + F13*G[123] + F14*G[59] + F15*G[61] + F16*G[62])) + F19*(F11*F11*G[5] + F12*(F11*G[28] + F12*G[265]) + F13*(F11*G[48] + F12*G[278] + F13*G[280]) + F14*(F11*G[93] + F12*G[99] + F13*G[122] + F14*G[22]) + F15*(F11*G[99] + F12*G[297] + F13*G[313] + F14*G[43] + F15*G[275]) + F16*(F11*G[122] + F12*G[313] + F13*G[314] + F14*G[61] + F15*G[287] + F16*G[288])) + F20*(F11*F11*G[7] + F12*(F11*G[30] + F12*G[267]) + F13*(F11*G[50] + F12*G[280] + F13*G[382]) + F14*(F11*G[94] + F12*G[119] + F13*G[120] + F14*G[23]) + F15*(F11*G[119] + F12*G[311] + F13*G[312] + F14*G[44] + F15*G[276]) + F16*(F11*G[120] + F12*G[312] + F13*G[393] + F14*G[62] + F15*G[288] + F16*G[386]))))));
      
      
      // Number of operations for primary indices: 1
      // Number of operations to compute entry: 1
      A[0] += I[0];
    } // end loop over 'ip'
  }

};


class pnp_and_source_form_0: public ufc::form
{
public:

  pnp_and_source_form_0() : ufc::form()
  {
    // Do nothing
  }

  ~pnp_and_source_form_0() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "866a88113e3edbf38a68abaf2596ef16580b705c6b7f7cec2cabb3a4cb184a446b79b2a8e59a13bbad07825034150c4b1bec33dd27125f23dba532bec4973fea";
  }

  std::size_t rank() const final override
  {
    return 2;
  }

  std::size_t num_coefficients() const final override
  {
    return 8;
  }

  std::size_t original_coefficient_position(std::size_t i) const final override
  {
    static const std::vector<std::size_t> position({0, 1, 2, 3, 4, 5, 6, 7});
    return position[i];
  }

  ufc::finite_element * create_coordinate_finite_element() const final override
  {
    return new pnp_and_source_finite_element_1();
  }

  ufc::dofmap * create_coordinate_dofmap() const final override
  {
    return new pnp_and_source_dofmap_1();
   }

  ufc::coordinate_mapping * create_coordinate_mapping() const final override
  {
    return nullptr;
  }

  ufc::finite_element * create_finite_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
      {
        return new pnp_and_source_finite_element_2();
        break;
      }
    case 1:
      {
        return new pnp_and_source_finite_element_2();
        break;
      }
    case 2:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 3:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 4:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 5:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 6:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 7:
      {
        return new pnp_and_source_finite_element_3();
        break;
      }
    case 8:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 9:
      {
        return new pnp_and_source_finite_element_3();
        break;
      }
    }
    
    return 0;
  }

  ufc::dofmap * create_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
      {
        return new pnp_and_source_dofmap_2();
        break;
      }
    case 1:
      {
        return new pnp_and_source_dofmap_2();
        break;
      }
    case 2:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 3:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 4:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 5:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 6:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 7:
      {
        return new pnp_and_source_dofmap_3();
        break;
      }
    case 8:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 9:
      {
        return new pnp_and_source_dofmap_3();
        break;
      }
    }
    
    return 0;
  }

  std::size_t max_cell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_exterior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_vertex_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_custom_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_cutcell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interface_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_overlap_subdomain_id() const final override
  {
    return 0;
  }

  bool has_cell_integrals() const final override
  {
    return true;
  }

  bool has_exterior_facet_integrals() const final override
  {
    return false;
  }

  bool has_interior_facet_integrals() const final override
  {
    return false;
  }

  bool has_vertex_integrals() const final override
  {
    return false;
  }

  bool has_custom_integrals() const final override
  {
    return false;
  }

  bool has_cutcell_integrals() const final override
  {
    return false;
  }

  bool has_interface_integrals() const final override
  {
    return false;
  }

  bool has_overlap_integrals() const final override
  {
    return false;
  }

  ufc::cell_integral * create_cell_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::exterior_facet_integral * create_exterior_facet_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::interior_facet_integral * create_interior_facet_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::vertex_integral * create_vertex_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::custom_integral * create_custom_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::cutcell_integral * create_cutcell_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::interface_integral * create_interface_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::overlap_integral * create_overlap_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::cell_integral * create_default_cell_integral() const final override
  {
    return new pnp_and_source_cell_integral_0_otherwise();
  }

  ufc::exterior_facet_integral * create_default_exterior_facet_integral() const final override
  {
    return 0;
  }

  ufc::interior_facet_integral * create_default_interior_facet_integral() const final override
  {
    return 0;
  }

  ufc::vertex_integral * create_default_vertex_integral() const final override
  {
    return 0;
  }

  ufc::custom_integral * create_default_custom_integral() const final override
  {
    return 0;
  }

  ufc::cutcell_integral * create_default_cutcell_integral() const final override
  {
    return 0;
  }

  ufc::interface_integral * create_default_interface_integral() const final override
  {
    return 0;
  }

  ufc::overlap_integral * create_default_overlap_integral() const final override
  {
    return 0;
  }

};


class pnp_and_source_form_1: public ufc::form
{
public:

  pnp_and_source_form_1() : ufc::form()
  {
    // Do nothing
  }

  ~pnp_and_source_form_1() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "72cb23fbd99ebdbed4ff907156796fc4a526ec95fe7dc514db3caa250a202bc707585783b837e13bb2322c06038d457a4738bfa4f3ab8f5ceda1c9ae82fa1b63";
  }

  std::size_t rank() const final override
  {
    return 1;
  }

  std::size_t num_coefficients() const final override
  {
    return 11;
  }

  std::size_t original_coefficient_position(std::size_t i) const final override
  {
    static const std::vector<std::size_t> position({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
    return position[i];
  }

  ufc::finite_element * create_coordinate_finite_element() const final override
  {
    return new pnp_and_source_finite_element_1();
  }

  ufc::dofmap * create_coordinate_dofmap() const final override
  {
    return new pnp_and_source_dofmap_1();
   }

  ufc::coordinate_mapping * create_coordinate_mapping() const final override
  {
    return nullptr;
  }

  ufc::finite_element * create_finite_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
      {
        return new pnp_and_source_finite_element_2();
        break;
      }
    case 1:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 2:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 3:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 4:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 5:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 6:
      {
        return new pnp_and_source_finite_element_3();
        break;
      }
    case 7:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 8:
      {
        return new pnp_and_source_finite_element_3();
        break;
      }
    case 9:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 10:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 11:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    }
    
    return 0;
  }

  ufc::dofmap * create_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
      {
        return new pnp_and_source_dofmap_2();
        break;
      }
    case 1:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 2:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 3:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 4:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 5:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 6:
      {
        return new pnp_and_source_dofmap_3();
        break;
      }
    case 7:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 8:
      {
        return new pnp_and_source_dofmap_3();
        break;
      }
    case 9:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 10:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 11:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    }
    
    return 0;
  }

  std::size_t max_cell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_exterior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_vertex_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_custom_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_cutcell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interface_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_overlap_subdomain_id() const final override
  {
    return 0;
  }

  bool has_cell_integrals() const final override
  {
    return true;
  }

  bool has_exterior_facet_integrals() const final override
  {
    return false;
  }

  bool has_interior_facet_integrals() const final override
  {
    return false;
  }

  bool has_vertex_integrals() const final override
  {
    return false;
  }

  bool has_custom_integrals() const final override
  {
    return false;
  }

  bool has_cutcell_integrals() const final override
  {
    return false;
  }

  bool has_interface_integrals() const final override
  {
    return false;
  }

  bool has_overlap_integrals() const final override
  {
    return false;
  }

  ufc::cell_integral * create_cell_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::exterior_facet_integral * create_exterior_facet_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::interior_facet_integral * create_interior_facet_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::vertex_integral * create_vertex_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::custom_integral * create_custom_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::cutcell_integral * create_cutcell_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::interface_integral * create_interface_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::overlap_integral * create_overlap_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::cell_integral * create_default_cell_integral() const final override
  {
    return new pnp_and_source_cell_integral_1_otherwise();
  }

  ufc::exterior_facet_integral * create_default_exterior_facet_integral() const final override
  {
    return 0;
  }

  ufc::interior_facet_integral * create_default_interior_facet_integral() const final override
  {
    return 0;
  }

  ufc::vertex_integral * create_default_vertex_integral() const final override
  {
    return 0;
  }

  ufc::custom_integral * create_default_custom_integral() const final override
  {
    return 0;
  }

  ufc::cutcell_integral * create_default_cutcell_integral() const final override
  {
    return 0;
  }

  ufc::interface_integral * create_default_interface_integral() const final override
  {
    return 0;
  }

  ufc::overlap_integral * create_default_overlap_integral() const final override
  {
    return 0;
  }

};


class pnp_and_source_form_2: public ufc::form
{
public:

  pnp_and_source_form_2() : ufc::form()
  {
    // Do nothing
  }

  ~pnp_and_source_form_2() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "19701e70eb62c1bf9f4b6094087ca38ebec383d80df6a0e194c5b9f3da342d3a7672ed6c73108fdfb32ddece8c31a0686caaceba85bb8684e81e706808a89616";
  }

  std::size_t rank() const final override
  {
    return 0;
  }

  std::size_t num_coefficients() const final override
  {
    return 11;
  }

  std::size_t original_coefficient_position(std::size_t i) const final override
  {
    static const std::vector<std::size_t> position({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
    return position[i];
  }

  ufc::finite_element * create_coordinate_finite_element() const final override
  {
    return new pnp_and_source_finite_element_1();
  }

  ufc::dofmap * create_coordinate_dofmap() const final override
  {
    return new pnp_and_source_dofmap_1();
   }

  ufc::coordinate_mapping * create_coordinate_mapping() const final override
  {
    return nullptr;
  }

  ufc::finite_element * create_finite_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 1:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 2:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 3:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 4:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 5:
      {
        return new pnp_and_source_finite_element_3();
        break;
      }
    case 6:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 7:
      {
        return new pnp_and_source_finite_element_3();
        break;
      }
    case 8:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 9:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    case 10:
      {
        return new pnp_and_source_finite_element_0();
        break;
      }
    }
    
    return 0;
  }

  ufc::dofmap * create_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 1:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 2:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 3:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 4:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 5:
      {
        return new pnp_and_source_dofmap_3();
        break;
      }
    case 6:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 7:
      {
        return new pnp_and_source_dofmap_3();
        break;
      }
    case 8:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 9:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    case 10:
      {
        return new pnp_and_source_dofmap_0();
        break;
      }
    }
    
    return 0;
  }

  std::size_t max_cell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_exterior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_vertex_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_custom_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_cutcell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interface_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_overlap_subdomain_id() const final override
  {
    return 0;
  }

  bool has_cell_integrals() const final override
  {
    return true;
  }

  bool has_exterior_facet_integrals() const final override
  {
    return false;
  }

  bool has_interior_facet_integrals() const final override
  {
    return false;
  }

  bool has_vertex_integrals() const final override
  {
    return false;
  }

  bool has_custom_integrals() const final override
  {
    return false;
  }

  bool has_cutcell_integrals() const final override
  {
    return false;
  }

  bool has_interface_integrals() const final override
  {
    return false;
  }

  bool has_overlap_integrals() const final override
  {
    return false;
  }

  ufc::cell_integral * create_cell_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::exterior_facet_integral * create_exterior_facet_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::interior_facet_integral * create_interior_facet_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::vertex_integral * create_vertex_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::custom_integral * create_custom_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::cutcell_integral * create_cutcell_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::interface_integral * create_interface_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::overlap_integral * create_overlap_integral(std::size_t subdomain_id) const final override
  {
    return 0;
  }

  ufc::cell_integral * create_default_cell_integral() const final override
  {
    return new pnp_and_source_cell_integral_2_otherwise();
  }

  ufc::exterior_facet_integral * create_default_exterior_facet_integral() const final override
  {
    return 0;
  }

  ufc::interior_facet_integral * create_default_interior_facet_integral() const final override
  {
    return 0;
  }

  ufc::vertex_integral * create_default_vertex_integral() const final override
  {
    return 0;
  }

  ufc::custom_integral * create_default_custom_integral() const final override
  {
    return 0;
  }

  ufc::cutcell_integral * create_default_cutcell_integral() const final override
  {
    return 0;
  }

  ufc::interface_integral * create_default_interface_integral() const final override
  {
    return 0;
  }

  ufc::overlap_integral * create_default_overlap_integral() const final override
  {
    return 0;
  }

};

// DOLFIN wrappers

// Standard library includes
#include <string>

// DOLFIN includes
#include <dolfin/common/NoDeleter.h>
#include <dolfin/mesh/Mesh.h>
#include <dolfin/mesh/MultiMesh.h>
#include <dolfin/fem/FiniteElement.h>
#include <dolfin/fem/DofMap.h>
#include <dolfin/fem/Form.h>
#include <dolfin/fem/MultiMeshForm.h>
#include <dolfin/function/FunctionSpace.h>
#include <dolfin/function/MultiMeshFunctionSpace.h>
#include <dolfin/function/GenericFunction.h>
#include <dolfin/function/CoefficientAssigner.h>
#include <dolfin/function/MultiMeshCoefficientAssigner.h>
#include <dolfin/adaptivity/ErrorControl.h>
#include <dolfin/adaptivity/GoalFunctional.h>
#include <dolfin/la/GenericVector.h>

namespace pnp_and_source
{

class CoefficientSpace_AnAn: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_AnAn(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_AnAn(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_CatCat: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_CatCat(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_CatCat(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_Dn: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_Dn(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_Dn(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_Dp: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_Dp(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_Dp(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_EsEs: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_EsEs(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_EsEs(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_anion: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_anion(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_anion(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_cation: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_cation(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_cation(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_eps: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_eps(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_eps(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_potential: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_potential(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_potential(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_0>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_qn: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_qn(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_3>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_3>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_qn(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_3>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_3>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_qp: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_qp(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_3>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_3>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_qp(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_3>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_3>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class Form_a_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  Form_a_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_2>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_2>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_a_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_2>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_2>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class Form_a_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  Form_a_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_2>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_2>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_a_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_2>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_2>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class Form_a_MultiMeshFunctionSpace_0: public dolfin::MultiMeshFunctionSpace
{
public:

  // Constructor for multimesh function space
  Form_a_MultiMeshFunctionSpace_0(std::shared_ptr<const dolfin::MultiMesh> multimesh): dolfin::MultiMeshFunctionSpace(multimesh)
  {
    // Create and add standard function spaces
    for (std::size_t part = 0; part < multimesh->num_parts(); part++)
    {
      std::shared_ptr<const dolfin::FunctionSpace> V(new Form_a_FunctionSpace_0(multimesh->part(part)));
      add(V);
    }

    // Build multimesh function space
    build();
  }

};

class Form_a_MultiMeshFunctionSpace_1: public dolfin::MultiMeshFunctionSpace
{
public:

  // Constructor for multimesh function space
  Form_a_MultiMeshFunctionSpace_1(std::shared_ptr<const dolfin::MultiMesh> multimesh): dolfin::MultiMeshFunctionSpace(multimesh)
  {
    // Create and add standard function spaces
    for (std::size_t part = 0; part < multimesh->num_parts(); part++)
    {
      std::shared_ptr<const dolfin::FunctionSpace> V(new Form_a_FunctionSpace_1(multimesh->part(part)));
      add(V);
    }

    // Build multimesh function space
    build();
  }

};

typedef CoefficientSpace_CatCat Form_a_FunctionSpace_2;

typedef CoefficientSpace_AnAn Form_a_FunctionSpace_3;

typedef CoefficientSpace_EsEs Form_a_FunctionSpace_4;

typedef CoefficientSpace_eps Form_a_FunctionSpace_5;

typedef CoefficientSpace_Dp Form_a_FunctionSpace_6;

typedef CoefficientSpace_qp Form_a_FunctionSpace_7;

typedef CoefficientSpace_Dn Form_a_FunctionSpace_8;

typedef CoefficientSpace_qn Form_a_FunctionSpace_9;

class Form_a: public dolfin::Form
{
public:

  // Constructor
  Form_a(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 8), CatCat(*this, 0), AnAn(*this, 1), EsEs(*this, 2), eps(*this, 3), Dp(*this, 4), qp(*this, 5), Dn(*this, 6), qn(*this, 7)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = std::make_shared<const pnp_and_source_form_0>();
  }

  // Constructor
  Form_a(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> CatCat, std::shared_ptr<const dolfin::GenericFunction> AnAn, std::shared_ptr<const dolfin::GenericFunction> EsEs, std::shared_ptr<const dolfin::GenericFunction> eps, std::shared_ptr<const dolfin::GenericFunction> Dp, std::shared_ptr<const dolfin::GenericFunction> qp, std::shared_ptr<const dolfin::GenericFunction> Dn, std::shared_ptr<const dolfin::GenericFunction> qn):
    dolfin::Form(2, 8), CatCat(*this, 0), AnAn(*this, 1), EsEs(*this, 2), eps(*this, 3), Dp(*this, 4), qp(*this, 5), Dn(*this, 6), qn(*this, 7)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->CatCat = CatCat;
    this->AnAn = AnAn;
    this->EsEs = EsEs;
    this->eps = eps;
    this->Dp = Dp;
    this->qp = qp;
    this->Dn = Dn;
    this->qn = qn;

    _ufc_form = std::make_shared<const pnp_and_source_form_0>();
  }

  // Destructor
  ~Form_a()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "CatCat")
      return 0;
    else if (name == "AnAn")
      return 1;
    else if (name == "EsEs")
      return 2;
    else if (name == "eps")
      return 3;
    else if (name == "Dp")
      return 4;
    else if (name == "qp")
      return 5;
    else if (name == "Dn")
      return 6;
    else if (name == "qn")
      return 7;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "CatCat";
    case 1:
      return "AnAn";
    case 2:
      return "EsEs";
    case 3:
      return "eps";
    case 4:
      return "Dp";
    case 5:
      return "qp";
    case 6:
      return "Dn";
    case 7:
      return "qn";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_a_FunctionSpace_0 TestSpace;
  typedef Form_a_FunctionSpace_1 TrialSpace;
  typedef Form_a_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_a_MultiMeshFunctionSpace_1 MultiMeshTrialSpace;
  typedef Form_a_FunctionSpace_2 CoefficientSpace_CatCat;
  typedef Form_a_FunctionSpace_3 CoefficientSpace_AnAn;
  typedef Form_a_FunctionSpace_4 CoefficientSpace_EsEs;
  typedef Form_a_FunctionSpace_5 CoefficientSpace_eps;
  typedef Form_a_FunctionSpace_6 CoefficientSpace_Dp;
  typedef Form_a_FunctionSpace_7 CoefficientSpace_qp;
  typedef Form_a_FunctionSpace_8 CoefficientSpace_Dn;
  typedef Form_a_FunctionSpace_9 CoefficientSpace_qn;

  // Coefficients
  dolfin::CoefficientAssigner CatCat;
  dolfin::CoefficientAssigner AnAn;
  dolfin::CoefficientAssigner EsEs;
  dolfin::CoefficientAssigner eps;
  dolfin::CoefficientAssigner Dp;
  dolfin::CoefficientAssigner qp;
  dolfin::CoefficientAssigner Dn;
  dolfin::CoefficientAssigner qn;
};

class MultiMeshForm_a: public dolfin::MultiMeshForm
{
public:

  // Constructor
  MultiMeshForm_a(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V1, std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0):
    dolfin::MultiMeshForm(V1, V0), CatCat(*this, 0), AnAn(*this, 1), EsEs(*this, 2), eps(*this, 3), Dp(*this, 4), qp(*this, 5), Dn(*this, 6), qn(*this, 7)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<const dolfin::Form> a(new Form_a(V1->part(part), V0->part(part)));
      add(a);
    }

    // Build multimesh form
    build();

    /// Assign coefficients

  }

  // Constructor
  MultiMeshForm_a(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V1, std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> CatCat, std::shared_ptr<const dolfin::GenericFunction> AnAn, std::shared_ptr<const dolfin::GenericFunction> EsEs, std::shared_ptr<const dolfin::GenericFunction> eps, std::shared_ptr<const dolfin::GenericFunction> Dp, std::shared_ptr<const dolfin::GenericFunction> qp, std::shared_ptr<const dolfin::GenericFunction> Dn, std::shared_ptr<const dolfin::GenericFunction> qn):
    dolfin::MultiMeshForm(V1, V0), CatCat(*this, 0), AnAn(*this, 1), EsEs(*this, 2), eps(*this, 3), Dp(*this, 4), qp(*this, 5), Dn(*this, 6), qn(*this, 7)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<const dolfin::Form> a(new Form_a(V1->part(part), V0->part(part)));
      add(a);
    }

    // Build multimesh form
    build();

    /// Assign coefficients
    this->CatCat = CatCat;
    this->AnAn = AnAn;
    this->EsEs = EsEs;
    this->eps = eps;
    this->Dp = Dp;
    this->qp = qp;
    this->Dn = Dn;
    this->qn = qn;

  }

  // Destructor
  ~MultiMeshForm_a()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "CatCat")
      return 0;
    else if (name == "AnAn")
      return 1;
    else if (name == "EsEs")
      return 2;
    else if (name == "eps")
      return 3;
    else if (name == "Dp")
      return 4;
    else if (name == "qp")
      return 5;
    else if (name == "Dn")
      return 6;
    else if (name == "qn")
      return 7;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "CatCat";
    case 1:
      return "AnAn";
    case 2:
      return "EsEs";
    case 3:
      return "eps";
    case 4:
      return "Dp";
    case 5:
      return "qp";
    case 6:
      return "Dn";
    case 7:
      return "qn";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_a_FunctionSpace_0 TestSpace;
  typedef Form_a_FunctionSpace_1 TrialSpace;
  typedef Form_a_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_a_MultiMeshFunctionSpace_1 MultiMeshTrialSpace;
  typedef Form_a_FunctionSpace_2 CoefficientSpace_CatCat;
  typedef Form_a_FunctionSpace_3 CoefficientSpace_AnAn;
  typedef Form_a_FunctionSpace_4 CoefficientSpace_EsEs;
  typedef Form_a_FunctionSpace_5 CoefficientSpace_eps;
  typedef Form_a_FunctionSpace_6 CoefficientSpace_Dp;
  typedef Form_a_FunctionSpace_7 CoefficientSpace_qp;
  typedef Form_a_FunctionSpace_8 CoefficientSpace_Dn;
  typedef Form_a_FunctionSpace_9 CoefficientSpace_qn;

  // Coefficients
  dolfin::MultiMeshCoefficientAssigner CatCat;
  dolfin::MultiMeshCoefficientAssigner AnAn;
  dolfin::MultiMeshCoefficientAssigner EsEs;
  dolfin::MultiMeshCoefficientAssigner eps;
  dolfin::MultiMeshCoefficientAssigner Dp;
  dolfin::MultiMeshCoefficientAssigner qp;
  dolfin::MultiMeshCoefficientAssigner Dn;
  dolfin::MultiMeshCoefficientAssigner qn;
};

class Form_L_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  Form_L_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_2>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_2>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_L_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<pnp_and_source_finite_element_2>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<pnp_and_source_dofmap_2>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class Form_L_MultiMeshFunctionSpace_0: public dolfin::MultiMeshFunctionSpace
{
public:

  // Constructor for multimesh function space
  Form_L_MultiMeshFunctionSpace_0(std::shared_ptr<const dolfin::MultiMesh> multimesh): dolfin::MultiMeshFunctionSpace(multimesh)
  {
    // Create and add standard function spaces
    for (std::size_t part = 0; part < multimesh->num_parts(); part++)
    {
      std::shared_ptr<const dolfin::FunctionSpace> V(new Form_L_FunctionSpace_0(multimesh->part(part)));
      add(V);
    }

    // Build multimesh function space
    build();
  }

};

typedef CoefficientSpace_CatCat Form_L_FunctionSpace_1;

typedef CoefficientSpace_AnAn Form_L_FunctionSpace_2;

typedef CoefficientSpace_EsEs Form_L_FunctionSpace_3;

typedef CoefficientSpace_eps Form_L_FunctionSpace_4;

typedef CoefficientSpace_Dp Form_L_FunctionSpace_5;

typedef CoefficientSpace_qp Form_L_FunctionSpace_6;

typedef CoefficientSpace_Dn Form_L_FunctionSpace_7;

typedef CoefficientSpace_qn Form_L_FunctionSpace_8;

typedef CoefficientSpace_cation Form_L_FunctionSpace_9;

typedef CoefficientSpace_anion Form_L_FunctionSpace_10;

typedef CoefficientSpace_potential Form_L_FunctionSpace_11;

class Form_L: public dolfin::Form
{
public:

  // Constructor
  Form_L(std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 11), CatCat(*this, 0), AnAn(*this, 1), EsEs(*this, 2), eps(*this, 3), Dp(*this, 4), qp(*this, 5), Dn(*this, 6), qn(*this, 7), cation(*this, 8), anion(*this, 9), potential(*this, 10)
  {
    _function_spaces[0] = V0;

    _ufc_form = std::make_shared<const pnp_and_source_form_1>();
  }

  // Constructor
  Form_L(std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> CatCat, std::shared_ptr<const dolfin::GenericFunction> AnAn, std::shared_ptr<const dolfin::GenericFunction> EsEs, std::shared_ptr<const dolfin::GenericFunction> eps, std::shared_ptr<const dolfin::GenericFunction> Dp, std::shared_ptr<const dolfin::GenericFunction> qp, std::shared_ptr<const dolfin::GenericFunction> Dn, std::shared_ptr<const dolfin::GenericFunction> qn, std::shared_ptr<const dolfin::GenericFunction> cation, std::shared_ptr<const dolfin::GenericFunction> anion, std::shared_ptr<const dolfin::GenericFunction> potential):
    dolfin::Form(1, 11), CatCat(*this, 0), AnAn(*this, 1), EsEs(*this, 2), eps(*this, 3), Dp(*this, 4), qp(*this, 5), Dn(*this, 6), qn(*this, 7), cation(*this, 8), anion(*this, 9), potential(*this, 10)
  {
    _function_spaces[0] = V0;

    this->CatCat = CatCat;
    this->AnAn = AnAn;
    this->EsEs = EsEs;
    this->eps = eps;
    this->Dp = Dp;
    this->qp = qp;
    this->Dn = Dn;
    this->qn = qn;
    this->cation = cation;
    this->anion = anion;
    this->potential = potential;

    _ufc_form = std::make_shared<const pnp_and_source_form_1>();
  }

  // Destructor
  ~Form_L()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "CatCat")
      return 0;
    else if (name == "AnAn")
      return 1;
    else if (name == "EsEs")
      return 2;
    else if (name == "eps")
      return 3;
    else if (name == "Dp")
      return 4;
    else if (name == "qp")
      return 5;
    else if (name == "Dn")
      return 6;
    else if (name == "qn")
      return 7;
    else if (name == "cation")
      return 8;
    else if (name == "anion")
      return 9;
    else if (name == "potential")
      return 10;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "CatCat";
    case 1:
      return "AnAn";
    case 2:
      return "EsEs";
    case 3:
      return "eps";
    case 4:
      return "Dp";
    case 5:
      return "qp";
    case 6:
      return "Dn";
    case 7:
      return "qn";
    case 8:
      return "cation";
    case 9:
      return "anion";
    case 10:
      return "potential";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_L_FunctionSpace_0 TestSpace;
  typedef Form_L_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_L_FunctionSpace_1 CoefficientSpace_CatCat;
  typedef Form_L_FunctionSpace_2 CoefficientSpace_AnAn;
  typedef Form_L_FunctionSpace_3 CoefficientSpace_EsEs;
  typedef Form_L_FunctionSpace_4 CoefficientSpace_eps;
  typedef Form_L_FunctionSpace_5 CoefficientSpace_Dp;
  typedef Form_L_FunctionSpace_6 CoefficientSpace_qp;
  typedef Form_L_FunctionSpace_7 CoefficientSpace_Dn;
  typedef Form_L_FunctionSpace_8 CoefficientSpace_qn;
  typedef Form_L_FunctionSpace_9 CoefficientSpace_cation;
  typedef Form_L_FunctionSpace_10 CoefficientSpace_anion;
  typedef Form_L_FunctionSpace_11 CoefficientSpace_potential;

  // Coefficients
  dolfin::CoefficientAssigner CatCat;
  dolfin::CoefficientAssigner AnAn;
  dolfin::CoefficientAssigner EsEs;
  dolfin::CoefficientAssigner eps;
  dolfin::CoefficientAssigner Dp;
  dolfin::CoefficientAssigner qp;
  dolfin::CoefficientAssigner Dn;
  dolfin::CoefficientAssigner qn;
  dolfin::CoefficientAssigner cation;
  dolfin::CoefficientAssigner anion;
  dolfin::CoefficientAssigner potential;
};

class MultiMeshForm_L: public dolfin::MultiMeshForm
{
public:

  // Constructor
  MultiMeshForm_L(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0):
    dolfin::MultiMeshForm(V0), CatCat(*this, 0), AnAn(*this, 1), EsEs(*this, 2), eps(*this, 3), Dp(*this, 4), qp(*this, 5), Dn(*this, 6), qn(*this, 7), cation(*this, 8), anion(*this, 9), potential(*this, 10)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<const dolfin::Form> a(new Form_L(V0->part(part)));
      add(a);
    }

    // Build multimesh form
    build();

    /// Assign coefficients

  }

  // Constructor
  MultiMeshForm_L(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> CatCat, std::shared_ptr<const dolfin::GenericFunction> AnAn, std::shared_ptr<const dolfin::GenericFunction> EsEs, std::shared_ptr<const dolfin::GenericFunction> eps, std::shared_ptr<const dolfin::GenericFunction> Dp, std::shared_ptr<const dolfin::GenericFunction> qp, std::shared_ptr<const dolfin::GenericFunction> Dn, std::shared_ptr<const dolfin::GenericFunction> qn, std::shared_ptr<const dolfin::GenericFunction> cation, std::shared_ptr<const dolfin::GenericFunction> anion, std::shared_ptr<const dolfin::GenericFunction> potential):
    dolfin::MultiMeshForm(V0), CatCat(*this, 0), AnAn(*this, 1), EsEs(*this, 2), eps(*this, 3), Dp(*this, 4), qp(*this, 5), Dn(*this, 6), qn(*this, 7), cation(*this, 8), anion(*this, 9), potential(*this, 10)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<const dolfin::Form> a(new Form_L(V0->part(part)));
      add(a);
    }

    // Build multimesh form
    build();

    /// Assign coefficients
    this->CatCat = CatCat;
    this->AnAn = AnAn;
    this->EsEs = EsEs;
    this->eps = eps;
    this->Dp = Dp;
    this->qp = qp;
    this->Dn = Dn;
    this->qn = qn;
    this->cation = cation;
    this->anion = anion;
    this->potential = potential;

  }

  // Destructor
  ~MultiMeshForm_L()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "CatCat")
      return 0;
    else if (name == "AnAn")
      return 1;
    else if (name == "EsEs")
      return 2;
    else if (name == "eps")
      return 3;
    else if (name == "Dp")
      return 4;
    else if (name == "qp")
      return 5;
    else if (name == "Dn")
      return 6;
    else if (name == "qn")
      return 7;
    else if (name == "cation")
      return 8;
    else if (name == "anion")
      return 9;
    else if (name == "potential")
      return 10;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "CatCat";
    case 1:
      return "AnAn";
    case 2:
      return "EsEs";
    case 3:
      return "eps";
    case 4:
      return "Dp";
    case 5:
      return "qp";
    case 6:
      return "Dn";
    case 7:
      return "qn";
    case 8:
      return "cation";
    case 9:
      return "anion";
    case 10:
      return "potential";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_L_FunctionSpace_0 TestSpace;
  typedef Form_L_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_L_FunctionSpace_1 CoefficientSpace_CatCat;
  typedef Form_L_FunctionSpace_2 CoefficientSpace_AnAn;
  typedef Form_L_FunctionSpace_3 CoefficientSpace_EsEs;
  typedef Form_L_FunctionSpace_4 CoefficientSpace_eps;
  typedef Form_L_FunctionSpace_5 CoefficientSpace_Dp;
  typedef Form_L_FunctionSpace_6 CoefficientSpace_qp;
  typedef Form_L_FunctionSpace_7 CoefficientSpace_Dn;
  typedef Form_L_FunctionSpace_8 CoefficientSpace_qn;
  typedef Form_L_FunctionSpace_9 CoefficientSpace_cation;
  typedef Form_L_FunctionSpace_10 CoefficientSpace_anion;
  typedef Form_L_FunctionSpace_11 CoefficientSpace_potential;

  // Coefficients
  dolfin::MultiMeshCoefficientAssigner CatCat;
  dolfin::MultiMeshCoefficientAssigner AnAn;
  dolfin::MultiMeshCoefficientAssigner EsEs;
  dolfin::MultiMeshCoefficientAssigner eps;
  dolfin::MultiMeshCoefficientAssigner Dp;
  dolfin::MultiMeshCoefficientAssigner qp;
  dolfin::MultiMeshCoefficientAssigner Dn;
  dolfin::MultiMeshCoefficientAssigner qn;
  dolfin::MultiMeshCoefficientAssigner cation;
  dolfin::MultiMeshCoefficientAssigner anion;
  dolfin::MultiMeshCoefficientAssigner potential;
};

typedef CoefficientSpace_CatCat Form_M_FunctionSpace_0;

typedef CoefficientSpace_AnAn Form_M_FunctionSpace_1;

typedef CoefficientSpace_EsEs Form_M_FunctionSpace_2;

typedef CoefficientSpace_eps Form_M_FunctionSpace_3;

typedef CoefficientSpace_Dp Form_M_FunctionSpace_4;

typedef CoefficientSpace_qp Form_M_FunctionSpace_5;

typedef CoefficientSpace_Dn Form_M_FunctionSpace_6;

typedef CoefficientSpace_qn Form_M_FunctionSpace_7;

typedef CoefficientSpace_cation Form_M_FunctionSpace_8;

typedef CoefficientSpace_anion Form_M_FunctionSpace_9;

typedef CoefficientSpace_potential Form_M_FunctionSpace_10;

class Form_M: public dolfin::Form
{
public:

  // Constructor
  Form_M(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::Form(0, 11), CatCat(*this, 0), AnAn(*this, 1), EsEs(*this, 2), eps(*this, 3), Dp(*this, 4), qp(*this, 5), Dn(*this, 6), qn(*this, 7), cation(*this, 8), anion(*this, 9), potential(*this, 10)
  {
    _mesh = mesh;
    _ufc_form = std::make_shared<const pnp_and_source_form_2>();
  }

  // Constructor
  Form_M(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::GenericFunction> CatCat, std::shared_ptr<const dolfin::GenericFunction> AnAn, std::shared_ptr<const dolfin::GenericFunction> EsEs, std::shared_ptr<const dolfin::GenericFunction> eps, std::shared_ptr<const dolfin::GenericFunction> Dp, std::shared_ptr<const dolfin::GenericFunction> qp, std::shared_ptr<const dolfin::GenericFunction> Dn, std::shared_ptr<const dolfin::GenericFunction> qn, std::shared_ptr<const dolfin::GenericFunction> cation, std::shared_ptr<const dolfin::GenericFunction> anion, std::shared_ptr<const dolfin::GenericFunction> potential):
    dolfin::Form(0, 11), CatCat(*this, 0), AnAn(*this, 1), EsEs(*this, 2), eps(*this, 3), Dp(*this, 4), qp(*this, 5), Dn(*this, 6), qn(*this, 7), cation(*this, 8), anion(*this, 9), potential(*this, 10)
  {
    _mesh = mesh;
    this->CatCat = CatCat;
    this->AnAn = AnAn;
    this->EsEs = EsEs;
    this->eps = eps;
    this->Dp = Dp;
    this->qp = qp;
    this->Dn = Dn;
    this->qn = qn;
    this->cation = cation;
    this->anion = anion;
    this->potential = potential;

    _ufc_form = std::make_shared<const pnp_and_source_form_2>();
  }

  // Destructor
  ~Form_M()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "CatCat")
      return 0;
    else if (name == "AnAn")
      return 1;
    else if (name == "EsEs")
      return 2;
    else if (name == "eps")
      return 3;
    else if (name == "Dp")
      return 4;
    else if (name == "qp")
      return 5;
    else if (name == "Dn")
      return 6;
    else if (name == "qn")
      return 7;
    else if (name == "cation")
      return 8;
    else if (name == "anion")
      return 9;
    else if (name == "potential")
      return 10;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "CatCat";
    case 1:
      return "AnAn";
    case 2:
      return "EsEs";
    case 3:
      return "eps";
    case 4:
      return "Dp";
    case 5:
      return "qp";
    case 6:
      return "Dn";
    case 7:
      return "qn";
    case 8:
      return "cation";
    case 9:
      return "anion";
    case 10:
      return "potential";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_M_FunctionSpace_0 CoefficientSpace_CatCat;
  typedef Form_M_FunctionSpace_1 CoefficientSpace_AnAn;
  typedef Form_M_FunctionSpace_2 CoefficientSpace_EsEs;
  typedef Form_M_FunctionSpace_3 CoefficientSpace_eps;
  typedef Form_M_FunctionSpace_4 CoefficientSpace_Dp;
  typedef Form_M_FunctionSpace_5 CoefficientSpace_qp;
  typedef Form_M_FunctionSpace_6 CoefficientSpace_Dn;
  typedef Form_M_FunctionSpace_7 CoefficientSpace_qn;
  typedef Form_M_FunctionSpace_8 CoefficientSpace_cation;
  typedef Form_M_FunctionSpace_9 CoefficientSpace_anion;
  typedef Form_M_FunctionSpace_10 CoefficientSpace_potential;

  // Coefficients
  dolfin::CoefficientAssigner CatCat;
  dolfin::CoefficientAssigner AnAn;
  dolfin::CoefficientAssigner EsEs;
  dolfin::CoefficientAssigner eps;
  dolfin::CoefficientAssigner Dp;
  dolfin::CoefficientAssigner qp;
  dolfin::CoefficientAssigner Dn;
  dolfin::CoefficientAssigner qn;
  dolfin::CoefficientAssigner cation;
  dolfin::CoefficientAssigner anion;
  dolfin::CoefficientAssigner potential;
};

class MultiMeshForm_M: public dolfin::MultiMeshForm
{
public:

  // Constructor
  MultiMeshForm_M(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::MultiMeshForm(), CatCat(*this, 0), AnAn(*this, 1), EsEs(*this, 2), eps(*this, 3), Dp(*this, 4), qp(*this, 5), Dn(*this, 6), qn(*this, 7), cation(*this, 8), anion(*this, 9), potential(*this, 10)
  {

    /// Assign coefficients

  }

  // Constructor
  MultiMeshForm_M(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::GenericFunction> CatCat, std::shared_ptr<const dolfin::GenericFunction> AnAn, std::shared_ptr<const dolfin::GenericFunction> EsEs, std::shared_ptr<const dolfin::GenericFunction> eps, std::shared_ptr<const dolfin::GenericFunction> Dp, std::shared_ptr<const dolfin::GenericFunction> qp, std::shared_ptr<const dolfin::GenericFunction> Dn, std::shared_ptr<const dolfin::GenericFunction> qn, std::shared_ptr<const dolfin::GenericFunction> cation, std::shared_ptr<const dolfin::GenericFunction> anion, std::shared_ptr<const dolfin::GenericFunction> potential):
    dolfin::MultiMeshForm(), CatCat(*this, 0), AnAn(*this, 1), EsEs(*this, 2), eps(*this, 3), Dp(*this, 4), qp(*this, 5), Dn(*this, 6), qn(*this, 7), cation(*this, 8), anion(*this, 9), potential(*this, 10)
  {

    /// Assign coefficients    this->CatCat = CatCat;
    this->AnAn = AnAn;
    this->EsEs = EsEs;
    this->eps = eps;
    this->Dp = Dp;
    this->qp = qp;
    this->Dn = Dn;
    this->qn = qn;
    this->cation = cation;
    this->anion = anion;
    this->potential = potential;

  }

  // Destructor
  ~MultiMeshForm_M()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "CatCat")
      return 0;
    else if (name == "AnAn")
      return 1;
    else if (name == "EsEs")
      return 2;
    else if (name == "eps")
      return 3;
    else if (name == "Dp")
      return 4;
    else if (name == "qp")
      return 5;
    else if (name == "Dn")
      return 6;
    else if (name == "qn")
      return 7;
    else if (name == "cation")
      return 8;
    else if (name == "anion")
      return 9;
    else if (name == "potential")
      return 10;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "CatCat";
    case 1:
      return "AnAn";
    case 2:
      return "EsEs";
    case 3:
      return "eps";
    case 4:
      return "Dp";
    case 5:
      return "qp";
    case 6:
      return "Dn";
    case 7:
      return "qn";
    case 8:
      return "cation";
    case 9:
      return "anion";
    case 10:
      return "potential";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_M_FunctionSpace_0 CoefficientSpace_CatCat;
  typedef Form_M_FunctionSpace_1 CoefficientSpace_AnAn;
  typedef Form_M_FunctionSpace_2 CoefficientSpace_EsEs;
  typedef Form_M_FunctionSpace_3 CoefficientSpace_eps;
  typedef Form_M_FunctionSpace_4 CoefficientSpace_Dp;
  typedef Form_M_FunctionSpace_5 CoefficientSpace_qp;
  typedef Form_M_FunctionSpace_6 CoefficientSpace_Dn;
  typedef Form_M_FunctionSpace_7 CoefficientSpace_qn;
  typedef Form_M_FunctionSpace_8 CoefficientSpace_cation;
  typedef Form_M_FunctionSpace_9 CoefficientSpace_anion;
  typedef Form_M_FunctionSpace_10 CoefficientSpace_potential;

  // Coefficients
  dolfin::MultiMeshCoefficientAssigner CatCat;
  dolfin::MultiMeshCoefficientAssigner AnAn;
  dolfin::MultiMeshCoefficientAssigner EsEs;
  dolfin::MultiMeshCoefficientAssigner eps;
  dolfin::MultiMeshCoefficientAssigner Dp;
  dolfin::MultiMeshCoefficientAssigner qp;
  dolfin::MultiMeshCoefficientAssigner Dn;
  dolfin::MultiMeshCoefficientAssigner qn;
  dolfin::MultiMeshCoefficientAssigner cation;
  dolfin::MultiMeshCoefficientAssigner anion;
  dolfin::MultiMeshCoefficientAssigner potential;
};

// Class typedefs
typedef Form_a BilinearForm;
typedef MultiMeshForm_a MultiMeshBilinearForm;
typedef Form_a JacobianForm;
typedef MultiMeshForm_a MultiMeshJacobianForm;
typedef Form_L LinearForm;
typedef MultiMeshForm_L MultiMeshLinearForm;
typedef Form_L ResidualForm;
typedef MultiMeshForm_L MultiMeshResidualForm;
typedef Form_M Functional;
typedef MultiMeshForm_M MultiMeshFunctional;
typedef Form_a::TestSpace FunctionSpace;
typedef Form_a::MultiMeshTestSpace MultiMeshFunctionSpace;

}

#endif
